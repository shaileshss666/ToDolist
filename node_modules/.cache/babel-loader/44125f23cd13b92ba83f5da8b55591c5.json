{"ast":null,"code":"'use strict';\n\nvar doctypes = require('doctypes');\n\nvar makeError = require('pug-error');\n\nvar buildRuntime = require('pug-runtime/build');\n\nvar runtime = require('pug-runtime');\n\nvar compileAttrs = require('pug-attrs');\n\nvar selfClosing = require('void-elements');\n\nvar constantinople = require('constantinople');\n\nvar stringify = require('js-stringify');\n\nvar addWith = require('with'); // This is used to prevent pretty printing inside certain tags\n\n\nvar WHITE_SPACE_SENSITIVE_TAGS = {\n  pre: true,\n  textarea: true\n};\nvar INTERNAL_VARIABLES = ['pug', 'pug_mixins', 'pug_interp', 'pug_debug_filename', 'pug_debug_line', 'pug_debug_sources', 'pug_html'];\nmodule.exports = generateCode;\nmodule.exports.CodeGenerator = Compiler;\n\nfunction generateCode(ast, options) {\n  return new Compiler(ast, options).compile();\n}\n\nfunction isConstant(src) {\n  return constantinople(src, {\n    pug: runtime,\n    pug_interp: undefined\n  });\n}\n\nfunction toConstant(src) {\n  return constantinople.toConstant(src, {\n    pug: runtime,\n    pug_interp: undefined\n  });\n}\n/**\n * Initialize `Compiler` with the given `node`.\n *\n * @param {Node} node\n * @param {Object} options\n * @api public\n */\n\n\nfunction Compiler(node, options) {\n  this.options = options = options || {};\n  this.node = node;\n  this.bufferedConcatenationCount = 0;\n  this.hasCompiledDoctype = false;\n  this.hasCompiledTag = false;\n  this.pp = options.pretty || false;\n\n  if (this.pp && typeof this.pp !== 'string') {\n    this.pp = '  ';\n  }\n\n  if (this.pp && !/^\\s+$/.test(this.pp)) {\n    throw new Error('The pretty parameter should either be a boolean or whitespace only string');\n  }\n\n  this.debug = false !== options.compileDebug;\n  this.indents = 0;\n  this.parentIndents = 0;\n  this.terse = false;\n  this.mixins = {};\n  this.dynamicMixins = false;\n  this.eachCount = 0;\n  if (options.doctype) this.setDoctype(options.doctype);\n  this.runtimeFunctionsUsed = [];\n  this.inlineRuntimeFunctions = options.inlineRuntimeFunctions || false;\n\n  if (this.debug && this.inlineRuntimeFunctions) {\n    this.runtimeFunctionsUsed.push('rethrow');\n  }\n}\n/**\n * Compiler prototype.\n */\n\n\nCompiler.prototype = {\n  runtime: function runtime(name) {\n    if (this.inlineRuntimeFunctions) {\n      this.runtimeFunctionsUsed.push(name);\n      return 'pug_' + name;\n    } else {\n      return 'pug.' + name;\n    }\n  },\n  error: function error(message, code, node) {\n    var err = makeError(code, message, {\n      line: node.line,\n      column: node.column,\n      filename: node.filename\n    });\n    throw err;\n  },\n\n  /**\n   * Compile parse tree to JavaScript.\n   *\n   * @api public\n   */\n  compile: function compile() {\n    this.buf = [];\n    if (this.pp) this.buf.push('var pug_indent = [];');\n    this.lastBufferedIdx = -1;\n    this.visit(this.node);\n\n    if (!this.dynamicMixins) {\n      // if there are no dynamic mixins we can remove any un-used mixins\n      var mixinNames = Object.keys(this.mixins);\n\n      for (var i = 0; i < mixinNames.length; i++) {\n        var mixin = this.mixins[mixinNames[i]];\n\n        if (!mixin.used) {\n          for (var x = 0; x < mixin.instances.length; x++) {\n            for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {\n              this.buf[y] = '';\n            }\n          }\n        }\n      }\n    }\n\n    var js = this.buf.join('\\n');\n    var globals = this.options.globals ? this.options.globals.concat(INTERNAL_VARIABLES) : INTERNAL_VARIABLES;\n\n    if (this.options.self) {\n      js = 'var self = locals || {};' + js;\n    } else {\n      js = addWith('locals || {}', js, globals.concat(this.runtimeFunctionsUsed.map(function (name) {\n        return 'pug_' + name;\n      })));\n    }\n\n    if (this.debug) {\n      if (this.options.includeSources) {\n        js = 'var pug_debug_sources = ' + stringify(this.options.includeSources) + ';\\n' + js;\n      }\n\n      js = 'var pug_debug_filename, pug_debug_line;' + 'try {' + js + '} catch (err) {' + (this.inlineRuntimeFunctions ? 'pug_rethrow' : 'pug.rethrow') + '(err, pug_debug_filename, pug_debug_line' + (this.options.includeSources ? ', pug_debug_sources[pug_debug_filename]' : '') + ');' + '}';\n    }\n\n    return buildRuntime(this.runtimeFunctionsUsed) + 'function ' + (this.options.templateName || 'template') + '(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;' + js + ';return pug_html;}';\n  },\n\n  /**\n   * Sets the default doctype `name`. Sets terse mode to `true` when\n   * html 5 is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {string} name\n   * @api public\n   */\n  setDoctype: function setDoctype(name) {\n    this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';\n    this.terse = this.doctype.toLowerCase() == '<!doctype html>';\n    this.xml = 0 == this.doctype.indexOf('<?xml');\n  },\n\n  /**\n   * Buffer the given `str` exactly as is or with interpolation\n   *\n   * @param {String} str\n   * @param {Boolean} interpolate\n   * @api public\n   */\n  buffer: function buffer(str) {\n    var self = this;\n    str = stringify(str);\n    str = str.substr(1, str.length - 2);\n\n    if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {\n      if (this.lastBufferedType === 'code') {\n        this.lastBuffered += ' + \"';\n        this.bufferedConcatenationCount++;\n      }\n\n      this.lastBufferedType = 'text';\n      this.lastBuffered += str;\n      this.buf[this.lastBufferedIdx - 1] = 'pug_html = pug_html + ' + this.bufferStartChar + this.lastBuffered + '\";';\n    } else {\n      this.bufferedConcatenationCount = 0;\n      this.buf.push('pug_html = pug_html + \"' + str + '\";');\n      this.lastBufferedType = 'text';\n      this.bufferStartChar = '\"';\n      this.lastBuffered = str;\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer the given `src` so it is evaluated at run time\n   *\n   * @param {String} src\n   * @api public\n   */\n  bufferExpression: function bufferExpression(src) {\n    if (isConstant(src)) {\n      return this.buffer(toConstant(src) + '');\n    }\n\n    if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {\n      this.bufferedConcatenationCount++;\n      if (this.lastBufferedType === 'text') this.lastBuffered += '\"';\n      this.lastBufferedType = 'code';\n      this.lastBuffered += ' + (' + src + ')';\n      this.buf[this.lastBufferedIdx - 1] = 'pug_html = pug_html + (' + this.bufferStartChar + this.lastBuffered + ');';\n    } else {\n      this.bufferedConcatenationCount = 0;\n      this.buf.push('pug_html = pug_html + (' + src + ');');\n      this.lastBufferedType = 'code';\n      this.bufferStartChar = '';\n      this.lastBuffered = '(' + src + ')';\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer an indent based on the current `indent`\n   * property and an additional `offset`.\n   *\n   * @param {Number} offset\n   * @param {Boolean} newline\n   * @api public\n   */\n  prettyIndent: function prettyIndent(offset, newline) {\n    offset = offset || 0;\n    newline = newline ? '\\n' : '';\n    this.buffer(newline + Array(this.indents + offset).join(this.pp));\n    if (this.parentIndents) this.buf.push('pug_html = pug_html + pug_indent.join(\"\");');\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n  visit: function visit(node, parent) {\n    var debug = this.debug;\n\n    if (!node) {\n      var msg;\n\n      if (parent) {\n        msg = 'A child of ' + parent.type + ' (' + (parent.filename || 'Pug') + ':' + parent.line + ')';\n      } else {\n        msg = 'A top-level node';\n      }\n\n      msg += ' is ' + node + ', expected a Pug AST Node.';\n      throw new TypeError(msg);\n    }\n\n    if (debug && node.debug !== false && node.type !== 'Block') {\n      if (node.line) {\n        var js = ';pug_debug_line = ' + node.line;\n        if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename);\n        this.buf.push(js + ';');\n      }\n    }\n\n    if (!this['visit' + node.type]) {\n      var msg;\n\n      if (parent) {\n        msg = 'A child of ' + parent.type;\n      } else {\n        msg = 'A top-level node';\n      }\n\n      msg += ' (' + (node.filename || 'Pug') + ':' + node.line + ')' + ' is of type ' + node.type + ',' + ' which is not supported by pug-code-gen.';\n\n      switch (node.type) {\n        case 'Filter':\n          msg += ' Please use pug-filters to preprocess this AST.';\n          break;\n\n        case 'Extends':\n        case 'Include':\n        case 'NamedBlock':\n        case 'FileReference':\n          // unlikely but for the sake of completeness\n          msg += ' Please use pug-linker to preprocess this AST.';\n          break;\n      }\n\n      throw new TypeError(msg);\n    }\n\n    this.visitNode(node);\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n  visitNode: function visitNode(node) {\n    return this['visit' + node.type](node);\n  },\n\n  /**\n   * Visit case `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n  visitCase: function visitCase(node) {\n    this.buf.push('switch (' + node.expr + '){');\n    this.visit(node.block, node);\n    this.buf.push('}');\n  },\n\n  /**\n   * Visit when `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n  visitWhen: function visitWhen(node) {\n    if ('default' == node.expr) {\n      this.buf.push('default:');\n    } else {\n      this.buf.push('case ' + node.expr + ':');\n    }\n\n    if (node.block) {\n      this.visit(node.block, node);\n      this.buf.push('  break;');\n    }\n  },\n\n  /**\n   * Visit literal `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n  visitLiteral: function visitLiteral(node) {\n    this.buffer(node.str);\n  },\n  visitNamedBlock: function visitNamedBlock(block) {\n    return this.visitBlock(block);\n  },\n\n  /**\n   * Visit all nodes in `block`.\n   *\n   * @param {Block} block\n   * @api public\n   */\n  visitBlock: function visitBlock(block) {\n    var escapePrettyMode = this.escapePrettyMode;\n    var pp = this.pp; // Pretty print multi-line text\n\n    if (pp && block.nodes.length > 1 && !escapePrettyMode && block.nodes[0].type === 'Text' && block.nodes[1].type === 'Text') {\n      this.prettyIndent(1, true);\n    }\n\n    for (var i = 0; i < block.nodes.length; ++i) {\n      // Pretty print text\n      if (pp && i > 0 && !escapePrettyMode && block.nodes[i].type === 'Text' && block.nodes[i - 1].type === 'Text' && /\\n$/.test(block.nodes[i - 1].val)) {\n        this.prettyIndent(1, false);\n      }\n\n      this.visit(block.nodes[i], block);\n    }\n  },\n\n  /**\n   * Visit a mixin's `block` keyword.\n   *\n   * @param {MixinBlock} block\n   * @api public\n   */\n  visitMixinBlock: function visitMixinBlock(block) {\n    if (this.pp) this.buf.push('pug_indent.push(' + stringify(Array(this.indents + 1).join(this.pp)) + ');');\n    this.buf.push('block && block();');\n    if (this.pp) this.buf.push('pug_indent.pop();');\n  },\n\n  /**\n   * Visit `doctype`. Sets terse mode to `true` when html 5\n   * is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {Doctype} doctype\n   * @api public\n   */\n  visitDoctype: function visitDoctype(doctype) {\n    if (doctype && (doctype.val || !this.doctype)) {\n      this.setDoctype(doctype.val || 'html');\n    }\n\n    if (this.doctype) this.buffer(this.doctype);\n    this.hasCompiledDoctype = true;\n  },\n\n  /**\n   * Visit `mixin`, generating a function that\n   * may be called within the template.\n   *\n   * @param {Mixin} mixin\n   * @api public\n   */\n  visitMixin: function visitMixin(mixin) {\n    var name = 'pug_mixins[';\n    var args = mixin.args || '';\n    var block = mixin.block;\n    var attrs = mixin.attrs;\n    var attrsBlocks = this.attributeBlocks(mixin.attributeBlocks);\n    var pp = this.pp;\n    var dynamic = mixin.name[0] === '#';\n    var key = mixin.name;\n    if (dynamic) this.dynamicMixins = true;\n    name += (dynamic ? mixin.name.substr(2, mixin.name.length - 3) : '\"' + mixin.name + '\"') + ']';\n    this.mixins[key] = this.mixins[key] || {\n      used: false,\n      instances: []\n    };\n\n    if (mixin.call) {\n      this.mixins[key].used = true;\n      if (pp) this.buf.push('pug_indent.push(' + stringify(Array(this.indents + 1).join(pp)) + ');');\n\n      if (block || attrs.length || attrsBlocks.length) {\n        this.buf.push(name + '.call({');\n\n        if (block) {\n          this.buf.push('block: function(){'); // Render block with no indents, dynamically added when rendered\n\n          this.parentIndents++;\n          var _indents = this.indents;\n          this.indents = 0;\n          this.visit(mixin.block, mixin);\n          this.indents = _indents;\n          this.parentIndents--;\n\n          if (attrs.length || attrsBlocks.length) {\n            this.buf.push('},');\n          } else {\n            this.buf.push('}');\n          }\n        }\n\n        if (attrsBlocks.length) {\n          if (attrs.length) {\n            var val = this.attrs(attrs);\n            attrsBlocks.unshift(val);\n          }\n\n          if (attrsBlocks.length > 1) {\n            this.buf.push('attributes: ' + this.runtime('merge') + '([' + attrsBlocks.join(',') + '])');\n          } else {\n            this.buf.push('attributes: ' + attrsBlocks[0]);\n          }\n        } else if (attrs.length) {\n          var val = this.attrs(attrs);\n          this.buf.push('attributes: ' + val);\n        }\n\n        if (args) {\n          this.buf.push('}, ' + args + ');');\n        } else {\n          this.buf.push('});');\n        }\n      } else {\n        this.buf.push(name + '(' + args + ');');\n      }\n\n      if (pp) this.buf.push('pug_indent.pop();');\n    } else {\n      var mixin_start = this.buf.length;\n      args = args ? args.split(',') : [];\n      var rest;\n\n      if (args.length && /^\\.\\.\\./.test(args[args.length - 1].trim())) {\n        rest = args.pop().trim().replace(/^\\.\\.\\./, '');\n      } // we need use pug_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165\n      // once fixed, use this: this.buf.push(name + ' = function(' + args.join(',') + '){');\n\n\n      this.buf.push(name + ' = pug_interp = function(' + args.join(',') + '){');\n      this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');\n\n      if (rest) {\n        this.buf.push('var ' + rest + ' = [];');\n        this.buf.push('for (pug_interp = ' + args.length + '; pug_interp < arguments.length; pug_interp++) {');\n        this.buf.push('  ' + rest + '.push(arguments[pug_interp]);');\n        this.buf.push('}');\n      }\n\n      this.parentIndents++;\n      this.visit(block, mixin);\n      this.parentIndents--;\n      this.buf.push('};');\n      var mixin_end = this.buf.length;\n      this.mixins[key].instances.push({\n        start: mixin_start,\n        end: mixin_end\n      });\n    }\n  },\n\n  /**\n   * Visit `tag` buffering tag markup, generating\n   * attributes, visiting the `tag`'s code and block.\n   *\n   * @param {Tag} tag\n   * @param {boolean} interpolated\n   * @api public\n   */\n  visitTag: function visitTag(tag, interpolated) {\n    this.indents++;\n    var name = tag.name,\n        pp = this.pp,\n        self = this;\n\n    function bufferName() {\n      if (interpolated) self.bufferExpression(tag.expr);else self.buffer(name);\n    }\n\n    if (WHITE_SPACE_SENSITIVE_TAGS[tag.name] === true) this.escapePrettyMode = true;\n\n    if (!this.hasCompiledTag) {\n      if (!this.hasCompiledDoctype && 'html' == name) {\n        this.visitDoctype();\n      }\n\n      this.hasCompiledTag = true;\n    } // pretty print\n\n\n    if (pp && !tag.isInline) this.prettyIndent(0, true);\n\n    if (tag.selfClosing || !this.xml && selfClosing[tag.name]) {\n      this.buffer('<');\n      bufferName();\n      this.visitAttributes(tag.attrs, this.attributeBlocks(tag.attributeBlocks));\n\n      if (this.terse && !tag.selfClosing) {\n        this.buffer('>');\n      } else {\n        this.buffer('/>');\n      } // if it is non-empty throw an error\n\n\n      if (tag.code || tag.block && !(tag.block.type === 'Block' && tag.block.nodes.length === 0) && tag.block.nodes.some(function (tag) {\n        return tag.type !== 'Text' || !/^\\s*$/.test(tag.val);\n      })) {\n        this.error(name + ' is a self closing element: <' + name + '/> but contains nested content.', 'SELF_CLOSING_CONTENT', tag);\n      }\n    } else {\n      // Optimize attributes buffering\n      this.buffer('<');\n      bufferName();\n      this.visitAttributes(tag.attrs, this.attributeBlocks(tag.attributeBlocks));\n      this.buffer('>');\n      if (tag.code) this.visitCode(tag.code);\n      this.visit(tag.block, tag); // pretty print\n\n      if (pp && !tag.isInline && WHITE_SPACE_SENSITIVE_TAGS[tag.name] !== true && !tagCanInline(tag)) this.prettyIndent(0, true);\n      this.buffer('</');\n      bufferName();\n      this.buffer('>');\n    }\n\n    if (WHITE_SPACE_SENSITIVE_TAGS[tag.name] === true) this.escapePrettyMode = false;\n    this.indents--;\n  },\n\n  /**\n   * Visit InterpolatedTag.\n   *\n   * @param {InterpolatedTag} tag\n   * @api public\n   */\n  visitInterpolatedTag: function visitInterpolatedTag(tag) {\n    return this.visitTag(tag, true);\n  },\n\n  /**\n   * Visit `text` node.\n   *\n   * @param {Text} text\n   * @api public\n   */\n  visitText: function visitText(text) {\n    this.buffer(text.val);\n  },\n\n  /**\n   * Visit a `comment`, only buffering when the buffer flag is set.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n  visitComment: function visitComment(comment) {\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + comment.val + '-->');\n  },\n\n  /**\n   * Visit a `YieldBlock`.\n   *\n   * This is necessary since we allow compiling a file with `yield`.\n   *\n   * @param {YieldBlock} block\n   * @api public\n   */\n  visitYieldBlock: function visitYieldBlock(block) {},\n\n  /**\n   * Visit a `BlockComment`.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n  visitBlockComment: function visitBlockComment(comment) {\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + (comment.val || ''));\n    this.visit(comment.block, comment);\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('-->');\n  },\n\n  /**\n   * Visit `code`, respecting buffer / escape flags.\n   * If the code is followed by a block, wrap it in\n   * a self-calling function.\n   *\n   * @param {Code} code\n   * @api public\n   */\n  visitCode: function visitCode(code) {\n    // Wrap code blocks with {}.\n    // we only wrap unbuffered code blocks ATM\n    // since they are usually flow control\n    // Buffer code\n    if (code.buffer) {\n      var val = code.val.trim();\n      val = 'null == (pug_interp = ' + val + ') ? \"\" : pug_interp';\n      if (code.mustEscape !== false) val = this.runtime('escape') + '(' + val + ')';\n      this.bufferExpression(val);\n    } else {\n      this.buf.push(code.val);\n    } // Block support\n\n\n    if (code.block) {\n      if (!code.buffer) this.buf.push('{');\n      this.visit(code.block, code);\n      if (!code.buffer) this.buf.push('}');\n    }\n  },\n\n  /**\n   * Visit `Conditional`.\n   *\n   * @param {Conditional} cond\n   * @api public\n   */\n  visitConditional: function visitConditional(cond) {\n    var test = cond.test;\n    this.buf.push('if (' + test + ') {');\n    this.visit(cond.consequent, cond);\n    this.buf.push('}');\n\n    if (cond.alternate) {\n      if (cond.alternate.type === 'Conditional') {\n        this.buf.push('else');\n        this.visitConditional(cond.alternate);\n      } else {\n        this.buf.push('else {');\n        this.visit(cond.alternate, cond);\n        this.buf.push('}');\n      }\n    }\n  },\n\n  /**\n   * Visit `While`.\n   *\n   * @param {While} loop\n   * @api public\n   */\n  visitWhile: function visitWhile(loop) {\n    var test = loop.test;\n    this.buf.push('while (' + test + ') {');\n    this.visit(loop.block, loop);\n    this.buf.push('}');\n  },\n\n  /**\n   * Visit `each` block.\n   *\n   * @param {Each} each\n   * @api public\n   */\n  visitEach: function visitEach(each) {\n    var indexVarName = each.key || 'pug_index' + this.eachCount;\n    this.eachCount++;\n    this.buf.push('' + '// iterate ' + each.obj + '\\n' + ';(function(){\\n' + '  var $$obj = ' + each.obj + ';\\n' + \"  if ('number' == typeof $$obj.length) {\");\n\n    if (each.alternate) {\n      this.buf.push('    if ($$obj.length) {');\n    }\n\n    this.buf.push('' + '      for (var ' + indexVarName + ' = 0, $$l = $$obj.length; ' + indexVarName + ' < $$l; ' + indexVarName + '++) {\\n' + '        var ' + each.val + ' = $$obj[' + indexVarName + '];');\n    this.visit(each.block, each);\n    this.buf.push('      }');\n\n    if (each.alternate) {\n      this.buf.push('    } else {');\n      this.visit(each.alternate, each);\n      this.buf.push('    }');\n    }\n\n    this.buf.push('' + '  } else {\\n' + '    var $$l = 0;\\n' + '    for (var ' + indexVarName + ' in $$obj) {\\n' + '      $$l++;\\n' + '      var ' + each.val + ' = $$obj[' + indexVarName + '];');\n    this.visit(each.block, each);\n    this.buf.push('    }');\n\n    if (each.alternate) {\n      this.buf.push('    if ($$l === 0) {');\n      this.visit(each.alternate, each);\n      this.buf.push('    }');\n    }\n\n    this.buf.push('  }\\n}).call(this);\\n');\n  },\n  visitEachOf: function visitEachOf(each) {\n    this.buf.push('' + '// iterate ' + each.obj + '\\n' + 'for (const ' + each.val + ' of ' + each.obj + ') {\\n');\n    this.visit(each.block, each);\n    this.buf.push('}\\n');\n  },\n\n  /**\n   * Visit `attrs`.\n   *\n   * @param {Array} attrs\n   * @api public\n   */\n  visitAttributes: function visitAttributes(attrs, attributeBlocks) {\n    if (attributeBlocks.length) {\n      if (attrs.length) {\n        var val = this.attrs(attrs);\n        attributeBlocks.unshift(val);\n      }\n\n      if (attributeBlocks.length > 1) {\n        this.bufferExpression(this.runtime('attrs') + '(' + this.runtime('merge') + '([' + attributeBlocks.join(',') + ']), ' + stringify(this.terse) + ')');\n      } else {\n        this.bufferExpression(this.runtime('attrs') + '(' + attributeBlocks[0] + ', ' + stringify(this.terse) + ')');\n      }\n    } else if (attrs.length) {\n      this.attrs(attrs, true);\n    }\n  },\n\n  /**\n   * Compile attributes.\n   */\n  attrs: function attrs(_attrs, buffer) {\n    var res = compileAttrs(_attrs, {\n      terse: this.terse,\n      format: buffer ? 'html' : 'object',\n      runtime: this.runtime.bind(this)\n    });\n\n    if (buffer) {\n      this.bufferExpression(res);\n    }\n\n    return res;\n  },\n\n  /**\n   * Compile attribute blocks.\n   */\n  attributeBlocks: function attributeBlocks(_attributeBlocks) {\n    return _attributeBlocks && _attributeBlocks.slice().map(function (attrBlock) {\n      return attrBlock.val;\n    });\n  }\n};\n\nfunction tagCanInline(tag) {\n  function isInline(node) {\n    // Recurse if the node is a block\n    if (node.type === 'Block') return node.nodes.every(isInline); // When there is a YieldBlock here, it is an indication that the file is\n    // expected to be included but is not. If this is the case, the block\n    // must be empty.\n\n    if (node.type === 'YieldBlock') return true;\n    return node.type === 'Text' && !/\\n/.test(node.val) || node.isInline;\n  }\n\n  return tag.block.nodes.every(isInline);\n}","map":null,"metadata":{},"sourceType":"script"}