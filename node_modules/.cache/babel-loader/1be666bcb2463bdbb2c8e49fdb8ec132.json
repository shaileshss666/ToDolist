{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\shail\\\\Desktop\\\\WEB designing\\\\Todo list\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar t = __importStar(require(\"@babel/types\"));\n\nif (!(Array.isArray(t.TYPES) && t.TYPES.every(function (t) {\n  return typeof t === 'string';\n}))) {\n  throw new Error('@babel/types TYPES does not match the expected type.');\n}\n\nvar FLIPPED_ALIAS_KEYS = t.FLIPPED_ALIAS_KEYS;\nvar TYPES = new Set(t.TYPES);\n\nif (!(FLIPPED_ALIAS_KEYS && // tslint:disable-next-line: strict-type-predicates\ntypeof FLIPPED_ALIAS_KEYS === 'object' && Object.keys(FLIPPED_ALIAS_KEYS).every(function (key) {\n  return Array.isArray(FLIPPED_ALIAS_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates\n  FLIPPED_ALIAS_KEYS[key].every(function (v) {\n    return typeof v === 'string';\n  });\n}))) {\n  throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');\n}\n/**\n * This serves thre functions:\n *\n * 1. Take any \"aliases\" and explode them to refecence the concrete types\n * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions\n * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged\n */\n\n\nfunction explode(input) {\n  var results = {};\n\n  for (var key in input) {\n    var aliases = FLIPPED_ALIAS_KEYS[key];\n\n    if (aliases) {\n      var _iterator = _createForOfIteratorHelper(aliases),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var concreteKey = _step.value;\n\n          if (concreteKey in results) {\n            if (typeof input[key] === 'function') {\n              results[concreteKey].enter.push(input[key]);\n            } else {\n              if (input[key].enter) results[concreteKey].enter.push(input[key].enter);\n              if (input[key].exit) results[concreteKey].exit.push(input[key].exit);\n            }\n          } else {\n            if (typeof input[key] === 'function') {\n              results[concreteKey] = {\n                enter: [input[key]],\n                exit: []\n              };\n            } else {\n              results[concreteKey] = {\n                enter: input[key].enter ? [input[key].enter] : [],\n                exit: input[key].exit ? [input[key].exit] : []\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else if (TYPES.has(key)) {\n      if (key in results) {\n        if (typeof input[key] === 'function') {\n          results[key].enter.push(input[key]);\n        } else {\n          if (input[key].enter) results[key].enter.push(input[key].enter);\n          if (input[key].exit) results[key].exit.push(input[key].exit);\n        }\n      } else {\n        if (typeof input[key] === 'function') {\n          results[key] = {\n            enter: [input[key]],\n            exit: []\n          };\n        } else {\n          results[key] = {\n            enter: input[key].enter ? [input[key].enter] : [],\n            exit: input[key].exit ? [input[key].exit] : []\n          };\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nexports.default = explode;","map":null,"metadata":{},"sourceType":"script"}