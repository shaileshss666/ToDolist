{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar parser_1 = require(\"@babel/parser\");\n\nvar b = require(\"@babel/types\");\n\nvar binaryOperation_1 = require(\"./binaryOperation\");\n\nfunction expressionToConstant(expression, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var constant = true;\n\n  function toConstant(expression) {\n    if (!constant) return;\n\n    if (b.isArrayExpression(expression)) {\n      var result_1 = [];\n\n      for (var i = 0; constant && i < expression.elements.length; i++) {\n        var element = expression.elements[i];\n\n        if (b.isSpreadElement(element)) {\n          var spread = toConstant(element.argument);\n\n          if (!(isSpreadable(spread) && constant)) {\n            constant = false;\n          } else {\n            result_1.push.apply(result_1, spread);\n          }\n        } else if (b.isExpression(element)) {\n          result_1.push(toConstant(element));\n        } else {\n          constant = false;\n        }\n      }\n\n      return result_1;\n    }\n\n    if (b.isBinaryExpression(expression)) {\n      var left = toConstant(expression.left);\n      var right = toConstant(expression.right);\n      return constant && binaryOperation_1[\"default\"](expression.operator, left, right);\n    }\n\n    if (b.isBooleanLiteral(expression)) {\n      return expression.value;\n    }\n\n    if (b.isCallExpression(expression)) {\n      var args = [];\n\n      for (var i = 0; constant && i < expression.arguments.length; i++) {\n        var arg = expression.arguments[i];\n\n        if (b.isSpreadElement(arg)) {\n          var spread = toConstant(arg.argument);\n\n          if (!(isSpreadable(spread) && constant)) {\n            constant = false;\n          } else {\n            args.push.apply(args, spread);\n          }\n        } else if (b.isExpression(arg)) {\n          args.push(toConstant(arg));\n        } else {\n          constant = false;\n        }\n      }\n\n      if (!constant) return;\n\n      if (b.isMemberExpression(expression.callee)) {\n        var object = toConstant(expression.callee.object);\n\n        if (!object || !constant) {\n          constant = false;\n          return;\n        }\n\n        var member = expression.callee.computed ? toConstant(expression.callee.property) : b.isIdentifier(expression.callee.property) ? expression.callee.property.name : undefined;\n\n        if (member === undefined && !expression.callee.computed) {\n          constant = false;\n        }\n\n        if (!constant) return;\n\n        if (canCallMethod(object, '' + member)) {\n          return object[member].apply(object, args);\n        }\n      } else {\n        if (!b.isExpression(expression.callee)) {\n          constant = false;\n          return;\n        }\n\n        var callee = toConstant(expression.callee);\n        if (!constant) return;\n        return callee.apply(null, args);\n      }\n    }\n\n    if (b.isConditionalExpression(expression)) {\n      var test = toConstant(expression.test);\n      return test ? toConstant(expression.consequent) : toConstant(expression.alternate);\n    }\n\n    if (b.isIdentifier(expression)) {\n      if (options.constants && {}.hasOwnProperty.call(options.constants, expression.name)) {\n        return options.constants[expression.name];\n      }\n    }\n\n    if (b.isLogicalExpression(expression)) {\n      var left = toConstant(expression.left);\n      var right = toConstant(expression.right);\n\n      if (constant && expression.operator === '&&') {\n        return left && right;\n      }\n\n      if (constant && expression.operator === '||') {\n        return left || right;\n      }\n    }\n\n    if (b.isMemberExpression(expression)) {\n      var object = toConstant(expression.object);\n\n      if (!object || !constant) {\n        constant = false;\n        return;\n      }\n\n      var member = expression.computed ? toConstant(expression.property) : b.isIdentifier(expression.property) ? expression.property.name : undefined;\n\n      if (member === undefined && !expression.computed) {\n        constant = false;\n      }\n\n      if (!constant) return;\n\n      if ({}.hasOwnProperty.call(object, '' + member) && member[0] !== '_') {\n        return object[member];\n      }\n    }\n\n    if (b.isNullLiteral(expression)) {\n      return null;\n    }\n\n    if (b.isNumericLiteral(expression)) {\n      return expression.value;\n    }\n\n    if (b.isObjectExpression(expression)) {\n      var result_2 = {};\n\n      for (var i = 0; constant && i < expression.properties.length; i++) {\n        var property = expression.properties[i];\n\n        if (b.isObjectProperty(property)) {\n          if (property.shorthand) {\n            constant = false;\n            return;\n          }\n\n          var key = property.computed ? toConstant(property.key) : b.isIdentifier(property.key) ? property.key.name : b.isStringLiteral(property.key) ? property.key.value : undefined;\n\n          if (!key || key[0] === '_') {\n            constant = false;\n          }\n\n          if (!constant) return;\n\n          if (b.isExpression(property.value)) {\n            var value = toConstant(property.value);\n            if (!constant) return;\n            result_2[key] = value;\n          } else {\n            constant = false;\n          }\n        } else if (b.isObjectMethod(property)) {\n          constant = false;\n        } else if (b.isSpreadProperty(property)) {\n          var argument = toConstant(property.argument);\n          if (!argument) constant = false;\n          if (!constant) return;\n          Object.assign(result_2, argument);\n        }\n      }\n\n      return result_2;\n    }\n\n    if (b.isParenthesizedExpression(expression)) {\n      return toConstant(expression.expression);\n    }\n\n    if (b.isRegExpLiteral(expression)) {\n      return new RegExp(expression.pattern, expression.flags);\n    }\n\n    if (b.isSequenceExpression(expression)) {\n      for (var i = 0; i < expression.expressions.length - 1 && constant; i++) {\n        toConstant(expression.expressions[i]);\n      }\n\n      return toConstant(expression.expressions[expression.expressions.length - 1]);\n    }\n\n    if (b.isStringLiteral(expression)) {\n      return expression.value;\n    } // TODO: TaggedTemplateExpression\n\n\n    if (b.isTemplateLiteral(expression)) {\n      var result_3 = '';\n\n      for (var i = 0; i < expression.quasis.length; i++) {\n        var quasi = expression.quasis[i];\n        result_3 += quasi.value.cooked;\n\n        if (i < expression.expressions.length) {\n          result_3 += '' + toConstant(expression.expressions[i]);\n        }\n      }\n\n      return result_3;\n    }\n\n    if (b.isUnaryExpression(expression)) {\n      var argument = toConstant(expression.argument);\n\n      if (!constant) {\n        return;\n      }\n\n      switch (expression.operator) {\n        case '-':\n          return -argument;\n\n        case '+':\n          return +argument;\n\n        case '!':\n          return !argument;\n\n        case '~':\n          return ~argument;\n\n        case 'typeof':\n          return typeof argument;\n\n        case 'void':\n          return void argument;\n      }\n    }\n\n    constant = false;\n  }\n\n  var result = toConstant(expression);\n  return constant ? {\n    constant: true,\n    result: result\n  } : {\n    constant: false\n  };\n}\n\nexports.expressionToConstant = expressionToConstant;\n\nfunction isSpreadable(value) {\n  return typeof value === 'string' || Array.isArray(value) || typeof Set !== 'undefined' && value instanceof Set || typeof Map !== 'undefined' && value instanceof Map;\n}\n\nfunction shallowEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    for (var key in a) {\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n\n    for (var key in b) {\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCallMethod(object, member) {\n  switch (typeof object) {\n    case 'boolean':\n      switch (member) {\n        case 'toString':\n          return true;\n\n        default:\n          return false;\n      }\n\n    case 'number':\n      switch (member) {\n        case 'toExponential':\n        case 'toFixed':\n        case 'toPrecision':\n        case 'toString':\n          return true;\n\n        default:\n          return false;\n      }\n\n    case 'string':\n      switch (member) {\n        case 'charAt':\n        case 'charCodeAt':\n        case 'codePointAt':\n        case 'concat':\n        case 'endsWith':\n        case 'includes':\n        case 'indexOf':\n        case 'lastIndexOf':\n        case 'match':\n        case 'normalize':\n        case 'padEnd':\n        case 'padStart':\n        case 'repeat':\n        case 'replace':\n        case 'search':\n        case 'slice':\n        case 'split':\n        case 'startsWith':\n        case 'substr':\n        case 'substring':\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          return true;\n\n        default:\n          return false;\n      }\n\n    default:\n      if (object instanceof RegExp) {\n        switch (member) {\n          case 'test':\n          case 'exec':\n            return true;\n\n          default:\n            return false;\n        }\n      }\n\n      return {}.hasOwnProperty.call(object, member) && member[0] !== '_';\n  }\n}\n\nvar EMPTY_OBJECT = {};\nvar lastSrc = '';\nvar lastConstants = EMPTY_OBJECT;\nvar lastOptions = EMPTY_OBJECT;\nvar lastResult = null;\nvar lastWasConstant = false;\n\nfunction isConstant(src, constants, options) {\n  if (constants === void 0) {\n    constants = EMPTY_OBJECT;\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (lastSrc === src && shallowEqual(lastConstants, constants) && shallowEqual(lastOptions, options)) {\n    return lastWasConstant;\n  }\n\n  lastSrc = src;\n  lastConstants = constants;\n  var ast;\n\n  try {\n    ast = parser_1.parseExpression(src, options);\n  } catch (ex) {\n    return lastWasConstant = false;\n  }\n\n  var _a = expressionToConstant(ast, {\n    constants: constants\n  }),\n      result = _a.result,\n      constant = _a.constant;\n\n  lastResult = result;\n  return lastWasConstant = constant;\n}\n\nexports.isConstant = isConstant;\n\nfunction toConstant(src, constants, options) {\n  if (constants === void 0) {\n    constants = EMPTY_OBJECT;\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (!isConstant(src, constants, options)) {\n    throw new Error(JSON.stringify(src) + ' is not constant.');\n  }\n\n  return lastResult;\n}\n\nexports.toConstant = toConstant;\nexports[\"default\"] = isConstant;\nmodule.exports = isConstant;\nmodule.exports[\"default\"] = isConstant;\nmodule.exports.expressionToConstant = expressionToConstant;\nmodule.exports.isConstant = isConstant;\nmodule.exports.toConstant = toConstant;","map":null,"metadata":{},"sourceType":"script"}