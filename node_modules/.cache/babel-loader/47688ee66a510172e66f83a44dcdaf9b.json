{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\shail\\\\Desktop\\\\WEB designing\\\\Todo list\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar parser_1 = require(\"@babel/parser\");\n\nvar babel_walk_1 = require(\"babel-walk\");\n\nvar t = __importStar(require(\"@babel/types\"));\n\nvar globals_1 = __importDefault(require(\"./globals\"));\n\nvar parseOptions = {\n  allowReturnOutsideFunction: true,\n  allowImportExportEverywhere: true\n};\n/**\n * Mimic `with` as far as possible but at compile time\n *\n * @param obj The object part of a with expression\n * @param src The body of the with expression\n * @param exclude A list of variable names to explicitly exclude\n */\n\nfunction addWith(obj, src) {\n  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  // tslint:disable-next-line: no-parameter-reassignment\n  obj = obj + ''; // tslint:disable-next-line: no-parameter-reassignment\n\n  src = src + '';\n  var ast;\n\n  try {\n    ast = parser_1.parse(src, parseOptions);\n  } catch (e) {\n    throw Object.assign(new Error('Error parsing body of the with expression'), {\n      component: 'src',\n      babylonError: e\n    });\n  }\n\n  var objAst;\n\n  try {\n    objAst = parser_1.parse(obj, parseOptions);\n  } catch (e) {\n    throw Object.assign(new Error('Error parsing object part of the with expression'), {\n      component: 'obj',\n      babylonError: e\n    });\n  }\n\n  var excludeSet = new Set(['undefined', 'this'].concat(_toConsumableArray(exclude), _toConsumableArray(globals_1.default(objAst).map(function (g) {\n    return g.name;\n  }))));\n  var vars = new Set(globals_1.default(ast).map(function (global) {\n    return global.name;\n  }).filter(function (v) {\n    return !excludeSet.has(v);\n  }));\n  if (vars.size === 0) return src;\n  var declareLocal = '';\n  var local = 'locals_for_with';\n  var result = 'result_of_with';\n\n  if (t.isValidIdentifier(obj)) {\n    local = obj;\n  } else {\n    while (vars.has(local) || excludeSet.has(local)) {\n      local += '_';\n    }\n\n    declareLocal = \"var \".concat(local, \" = (\").concat(obj, \");\");\n  }\n\n  while (vars.has(result) || excludeSet.has(result)) {\n    result += '_';\n  }\n\n  var args = ['this'].concat(_toConsumableArray(Array.from(vars).map(function (v) {\n    return \"\".concat(JSON.stringify(v), \" in \").concat(local, \" ?\\n        \").concat(local, \".\").concat(v, \" :\\n        typeof \").concat(v, \" !== 'undefined' ? \").concat(v, \" : undefined\");\n  })));\n  var unwrapped = unwrapReturns(ast, src, result);\n  return \";\\n    \".concat(declareLocal, \"\\n    \").concat(unwrapped.before, \"\\n    (function (\").concat(Array.from(vars).join(', '), \") {\\n      \").concat(unwrapped.body, \"\\n    }.call(\").concat(args.join(', '), \"));\\n    \").concat(unwrapped.after, \";\");\n}\n\nexports.default = addWith;\nvar unwrapReturnsVisitors = babel_walk_1.recursive({\n  Function: function Function(_node, _state, _c) {// returns in these functions are not applicable\n  },\n  ReturnStatement: function ReturnStatement(node, state) {\n    state.hasReturn = true;\n    var value = '';\n\n    if (node.argument) {\n      value = \"value: (\".concat(state.source(node.argument), \")\");\n    }\n\n    state.replace(node, \"return {\".concat(value, \"};\"));\n  }\n});\n/**\n * Take a self calling function, and unwrap it such that return inside the function\n * results in return outside the function\n *\n * @param src    Some JavaScript code representing a self-calling function\n * @param result A temporary variable to store the result in\n */\n\nfunction unwrapReturns(ast, src, result) {\n  var charArray = src.split('');\n  var state = {\n    hasReturn: false,\n    source: function source(node) {\n      return src.slice(node.start, node.end);\n    },\n    replace: function replace(node, str) {\n      charArray.fill('', node.start, node.end);\n      charArray[node.start] = str;\n    }\n  };\n  unwrapReturnsVisitors(ast, state);\n  return {\n    before: state.hasReturn ? \"var \".concat(result, \" = \") : '',\n    body: charArray.join(''),\n    after: state.hasReturn ? \";if (\".concat(result, \") return \").concat(result, \".value\") : ''\n  };\n}\n\nmodule.exports = addWith;\nmodule.exports.default = addWith;","map":null,"metadata":{},"sourceType":"script"}