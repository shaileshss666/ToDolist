{"ast":null,"code":"'use strict';\n\nvar objIsRegex = require('is-regex');\n\nexports = module.exports = parse;\nvar TOKEN_TYPES = exports.TOKEN_TYPES = {\n  LINE_COMMENT: '//',\n  BLOCK_COMMENT: '/**/',\n  SINGLE_QUOTE: '\\'',\n  DOUBLE_QUOTE: '\"',\n  TEMPLATE_QUOTE: '`',\n  REGEXP: '//g'\n};\nvar BRACKETS = exports.BRACKETS = {\n  '(': ')',\n  '{': '}',\n  '[': ']'\n};\nvar BRACKETS_REVERSED = {\n  ')': '(',\n  '}': '{',\n  ']': '['\n};\nexports.parse = parse;\n\nfunction parse(src, state, options) {\n  options = options || {};\n  state = state || exports.defaultState();\n  var start = options.start || 0;\n  var end = options.end || src.length;\n  var index = start;\n\n  while (index < end) {\n    try {\n      parseChar(src[index], state);\n    } catch (ex) {\n      ex.index = index;\n      throw ex;\n    }\n\n    index++;\n  }\n\n  return state;\n}\n\nexports.parseUntil = parseUntil;\n\nfunction parseUntil(src, delimiter, options) {\n  options = options || {};\n  var start = options.start || 0;\n  var index = start;\n  var state = exports.defaultState();\n\n  while (index < src.length) {\n    if ((options.ignoreNesting || !state.isNesting(options)) && matches(src, delimiter, index)) {\n      var end = index;\n      return {\n        start: start,\n        end: end,\n        src: src.substring(start, end)\n      };\n    }\n\n    try {\n      parseChar(src[index], state);\n    } catch (ex) {\n      ex.index = index;\n      throw ex;\n    }\n\n    index++;\n  }\n\n  var err = new Error('The end of the string was reached with no closing bracket found.');\n  err.code = 'CHARACTER_PARSER:END_OF_STRING_REACHED';\n  err.index = index;\n  throw err;\n}\n\nexports.parseChar = parseChar;\n\nfunction parseChar(character, state) {\n  if (character.length !== 1) {\n    var err = new Error('Character must be a string of length 1');\n    err.name = 'InvalidArgumentError';\n    err.code = 'CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE';\n    throw err;\n  }\n\n  state = state || exports.defaultState();\n  state.src += character;\n  var wasComment = state.isComment();\n  var lastChar = state.history ? state.history[0] : '';\n\n  if (state.regexpStart) {\n    if (character === '/' || character == '*') {\n      state.stack.pop();\n    }\n\n    state.regexpStart = false;\n  }\n\n  switch (state.current()) {\n    case TOKEN_TYPES.LINE_COMMENT:\n      if (character === '\\n') {\n        state.stack.pop();\n      }\n\n      break;\n\n    case TOKEN_TYPES.BLOCK_COMMENT:\n      if (state.lastChar === '*' && character === '/') {\n        state.stack.pop();\n      }\n\n      break;\n\n    case TOKEN_TYPES.SINGLE_QUOTE:\n      if (character === '\\'' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n\n      break;\n\n    case TOKEN_TYPES.DOUBLE_QUOTE:\n      if (character === '\"' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n\n      break;\n\n    case TOKEN_TYPES.TEMPLATE_QUOTE:\n      if (character === '`' && !state.escaped) {\n        state.stack.pop();\n        state.hasDollar = false;\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n        state.hasDollar = false;\n      } else if (character === '$' && !state.escaped) {\n        state.hasDollar = true;\n      } else if (character === '{' && state.hasDollar) {\n        state.stack.push(BRACKETS[character]);\n      } else {\n        state.escaped = false;\n        state.hasDollar = false;\n      }\n\n      break;\n\n    case TOKEN_TYPES.REGEXP:\n      if (character === '/' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n\n      break;\n\n    default:\n      if (character in BRACKETS) {\n        state.stack.push(BRACKETS[character]);\n      } else if (character in BRACKETS_REVERSED) {\n        if (state.current() !== character) {\n          var err = new SyntaxError('Mismatched Bracket: ' + character);\n          err.code = 'CHARACTER_PARSER:MISMATCHED_BRACKET';\n          throw err;\n        }\n\n        ;\n        state.stack.pop();\n      } else if (lastChar === '/' && character === '/') {\n        // Don't include comments in history\n        state.history = state.history.substr(1);\n        state.stack.push(TOKEN_TYPES.LINE_COMMENT);\n      } else if (lastChar === '/' && character === '*') {\n        // Don't include comment in history\n        state.history = state.history.substr(1);\n        state.stack.push(TOKEN_TYPES.BLOCK_COMMENT);\n      } else if (character === '/' && isRegexp(state.history)) {\n        state.stack.push(TOKEN_TYPES.REGEXP); // N.B. if the next character turns out to be a `*` or a `/`\n        //      then this isn't actually a regexp\n\n        state.regexpStart = true;\n      } else if (character === '\\'') {\n        state.stack.push(TOKEN_TYPES.SINGLE_QUOTE);\n      } else if (character === '\"') {\n        state.stack.push(TOKEN_TYPES.DOUBLE_QUOTE);\n      } else if (character === '`') {\n        state.stack.push(TOKEN_TYPES.TEMPLATE_QUOTE);\n      }\n\n      break;\n  }\n\n  if (!state.isComment() && !wasComment) {\n    state.history = character + state.history;\n  }\n\n  state.lastChar = character; // store last character for ending block comments\n\n  return state;\n}\n\nexports.defaultState = function () {\n  return new State();\n};\n\nfunction State() {\n  this.stack = [];\n  this.regexpStart = false;\n  this.escaped = false;\n  this.hasDollar = false;\n  this.src = '';\n  this.history = '';\n  this.lastChar = '';\n}\n\nState.prototype.current = function () {\n  return this.stack[this.stack.length - 1];\n};\n\nState.prototype.isString = function () {\n  return this.current() === TOKEN_TYPES.SINGLE_QUOTE || this.current() === TOKEN_TYPES.DOUBLE_QUOTE || this.current() === TOKEN_TYPES.TEMPLATE_QUOTE;\n};\n\nState.prototype.isComment = function () {\n  return this.current() === TOKEN_TYPES.LINE_COMMENT || this.current() === TOKEN_TYPES.BLOCK_COMMENT;\n};\n\nState.prototype.isNesting = function (opts) {\n  if (opts && opts.ignoreLineComment && this.stack.length === 1 && this.stack[0] === TOKEN_TYPES.LINE_COMMENT) {\n    // if we are only inside a line comment, and line comments are ignored\n    // don't count it as nesting\n    return false;\n  }\n\n  return !!this.stack.length;\n};\n\nfunction matches(str, matcher, i) {\n  if (objIsRegex(matcher)) {\n    return matcher.test(str.substr(i || 0));\n  } else {\n    return str.substr(i || 0, matcher.length) === matcher;\n  }\n}\n\nexports.isPunctuator = isPunctuator;\n\nfunction isPunctuator(c) {\n  if (!c) return true; // the start of a string is a punctuator\n\n  var code = c.charCodeAt(0);\n\n  switch (code) {\n    case 46: // . dot\n\n    case 40: // ( open bracket\n\n    case 41: // ) close bracket\n\n    case 59: // ; semicolon\n\n    case 44: // , comma\n\n    case 123: // { open curly brace\n\n    case 125: // } close curly brace\n\n    case 91: // [\n\n    case 93: // ]\n\n    case 58: // :\n\n    case 63: // ?\n\n    case 126: // ~\n\n    case 37: // %\n\n    case 38: // &\n\n    case 42: // *:\n\n    case 43: // +\n\n    case 45: // -\n\n    case 47: // /\n\n    case 60: // <\n\n    case 62: // >\n\n    case 94: // ^\n\n    case 124: // |\n\n    case 33: // !\n\n    case 61:\n      // =\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.isKeyword = isKeyword;\n\nfunction isKeyword(id) {\n  return id === 'if' || id === 'in' || id === 'do' || id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let' || id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum' || id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super' || id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import' || id === 'default' || id === 'finally' || id === 'extends' || id === 'function' || id === 'continue' || id === 'debugger' || id === 'package' || id === 'private' || id === 'interface' || id === 'instanceof' || id === 'implements' || id === 'protected' || id === 'public' || id === 'static';\n}\n\nfunction isRegexp(history) {\n  //could be start of regexp or divide sign\n  history = history.replace(/^\\s*/, ''); //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide\n\n  if (history[0] === ')') return false; //unless it's a function expression, it's a regexp, so we assume it's a regexp\n\n  if (history[0] === '}') return true; //any punctuation means it's a regexp\n\n  if (isPunctuator(history[0])) return true; //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)\n\n  if (/^\\w+\\b/.test(history) && isKeyword(/^\\w+\\b/.exec(history)[0].split('').reverse().join(''))) return true;\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}