{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\shail\\\\Desktop\\\\WEB designing\\\\Todo list\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\shail\\\\Desktop\\\\WEB designing\\\\Todo list\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\shail\\\\Desktop\\\\WEB designing\\\\Todo list\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_never_1 = __importDefault(require(\"assert-never\"));\n\nvar babel_walk_1 = require(\"babel-walk\");\n\nvar t = __importStar(require(\"@babel/types\"));\n\nvar reference_1 = __importDefault(require(\"./reference\"));\n\nvar isScope = function isScope(node) {\n  return t.isFunctionParent(node) || t.isProgram(node);\n};\n\nvar isBlockScope = function isBlockScope(node) {\n  return t.isBlockStatement(node) || isScope(node);\n};\n\nvar declaresArguments = function declaresArguments(node) {\n  return t.isFunction(node) && !t.isArrowFunctionExpression(node);\n};\n\nvar declaresThis = declaresArguments;\nvar LOCALS_SYMBOL = Symbol('locals');\n\nvar getLocals = function getLocals(node) {\n  return node[LOCALS_SYMBOL];\n};\n\nvar declareLocals = function declareLocals(node) {\n  return node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set();\n};\n\nvar setLocal = function setLocal(node, name) {\n  return declareLocals(node).add(name);\n}; // First pass\n\n\nfunction declareFunction(node) {\n  var _iterator = _createForOfIteratorHelper(node.params),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var param = _step.value;\n      declarePattern(param, node);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var id = node.id;\n\n  if (id) {\n    setLocal(node, id.name);\n  }\n}\n\nfunction declarePattern(node, parent) {\n  switch (node.type) {\n    case 'Identifier':\n      setLocal(parent, node.name);\n      break;\n\n    case 'ObjectPattern':\n      var _iterator2 = _createForOfIteratorHelper(node.properties),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var prop = _step2.value;\n\n          switch (prop.type) {\n            case 'RestElement':\n              declarePattern(prop.argument, parent);\n              break;\n\n            case 'ObjectProperty':\n              declarePattern(prop.value, parent);\n              break;\n\n            default:\n              assert_never_1.default(prop);\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      break;\n\n    case 'ArrayPattern':\n      var _iterator3 = _createForOfIteratorHelper(node.elements),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var element = _step3.value;\n          if (element) declarePattern(element, parent);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      break;\n\n    case 'RestElement':\n      declarePattern(node.argument, parent);\n      break;\n\n    case 'AssignmentPattern':\n      declarePattern(node.left, parent);\n      break;\n    // istanbul ignore next\n\n    default:\n      throw new Error('Unrecognized pattern type: ' + node.type);\n  }\n}\n\nfunction declareModuleSpecifier(node, _state, parents) {\n  for (var i = parents.length - 2; i >= 0; i--) {\n    if (isScope(parents[i])) {\n      setLocal(parents[i], node.local.name);\n      return;\n    }\n  }\n}\n\nvar firstPass = babel_walk_1.ancestor({\n  VariableDeclaration: function VariableDeclaration(node, _state, parents) {\n    for (var i = parents.length - 2; i >= 0; i--) {\n      if (node.kind === 'var' ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {\n        var _iterator4 = _createForOfIteratorHelper(node.declarations),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var declaration = _step4.value;\n            declarePattern(declaration.id, parents[i]);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return;\n      }\n    }\n  },\n  FunctionDeclaration: function FunctionDeclaration(node, _state, parents) {\n    if (node.id) {\n      for (var i = parents.length - 2; i >= 0; i--) {\n        if (isScope(parents[i])) {\n          setLocal(parents[i], node.id.name);\n          return;\n        }\n      }\n    }\n  },\n  Function: declareFunction,\n  ClassDeclaration: function ClassDeclaration(node, _state, parents) {\n    for (var i = parents.length - 2; i >= 0; i--) {\n      if (isScope(parents[i])) {\n        setLocal(parents[i], node.id.name);\n        return;\n      }\n    }\n  },\n  TryStatement: function TryStatement(node) {\n    if (node.handler === null) return;\n    if (node.handler.param === null) return;\n    declarePattern(node.handler.param, node.handler);\n  },\n  ImportDefaultSpecifier: declareModuleSpecifier,\n  ImportSpecifier: declareModuleSpecifier,\n  ImportNamespaceSpecifier: declareModuleSpecifier\n}); // Second pass\n\nvar secondPass = babel_walk_1.ancestor({\n  Identifier: function Identifier(node, state, parents) {\n    var _a;\n\n    var name = node.name;\n    if (name === 'undefined') return;\n    var lastParent = parents[parents.length - 2];\n\n    if (lastParent) {\n      if (!reference_1.default(node, lastParent)) return;\n\n      var _iterator5 = _createForOfIteratorHelper(parents),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var parent = _step5.value;\n\n          if (name === 'arguments' && declaresArguments(parent)) {\n            return;\n          }\n\n          if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) {\n            return;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n\n    state.globals.push(node);\n  },\n  ThisExpression: function ThisExpression(node, state, parents) {\n    var _iterator6 = _createForOfIteratorHelper(parents),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var parent = _step6.value;\n\n        if (declaresThis(parent)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    state.globals.push(node);\n  }\n});\n\nfunction findGlobals(ast) {\n  var globals = []; // istanbul ignore if\n\n  if (!t.isNode(ast)) {\n    throw new TypeError('Source must be a Babylon AST');\n  }\n\n  firstPass(ast, undefined);\n  secondPass(ast, {\n    globals: globals\n  });\n  var groupedGlobals = new Map();\n\n  for (var _i = 0, _globals = globals; _i < _globals.length; _i++) {\n    var node = _globals[_i];\n    var name = node.type === 'ThisExpression' ? 'this' : node.name;\n    var existing = groupedGlobals.get(name);\n\n    if (existing) {\n      existing.push(node);\n    } else {\n      groupedGlobals.set(name, [node]);\n    }\n  }\n\n  return _toConsumableArray(groupedGlobals).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        nodes = _ref2[1];\n\n    return {\n      name: name,\n      nodes: nodes\n    };\n  }).sort(function (a, b) {\n    return a.name < b.name ? -1 : 1;\n  });\n}\n\nexports.default = findGlobals;","map":null,"metadata":{},"sourceType":"script"}