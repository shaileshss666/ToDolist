{"ast":null,"code":"'use strict';\n\nmodule.exports = walkAST;\n\nfunction walkAST(ast, before, after, options) {\n  if (after && typeof after === 'object' && typeof options === 'undefined') {\n    options = after;\n    after = null;\n  }\n\n  options = options || {\n    includeDependencies: false\n  };\n  var parents = options.parents = options.parents || [];\n\n  var replace = function replace(replacement) {\n    if (Array.isArray(replacement) && !replace.arrayAllowed) {\n      throw new Error('replace() can only be called with an array if the last parent is a Block or NamedBlock');\n    }\n\n    ast = replacement;\n  };\n\n  replace.arrayAllowed = parents[0] && (/^(Named)?Block$/.test(parents[0].type) || parents[0].type === 'RawInclude' && ast.type === 'IncludeFilter');\n\n  if (before) {\n    var result = before(ast, replace);\n\n    if (result === false) {\n      return ast;\n    } else if (Array.isArray(ast)) {\n      // return right here to skip after() call on array\n      return walkAndMergeNodes(ast);\n    }\n  }\n\n  parents.unshift(ast);\n\n  switch (ast.type) {\n    case 'NamedBlock':\n    case 'Block':\n      ast.nodes = walkAndMergeNodes(ast.nodes);\n      break;\n\n    case 'Case':\n    case 'Filter':\n    case 'Mixin':\n    case 'Tag':\n    case 'InterpolatedTag':\n    case 'When':\n    case 'Code':\n    case 'While':\n      if (ast.block) {\n        ast.block = walkAST(ast.block, before, after, options);\n      }\n\n      break;\n\n    case 'Each':\n      if (ast.block) {\n        ast.block = walkAST(ast.block, before, after, options);\n      }\n\n      if (ast.alternate) {\n        ast.alternate = walkAST(ast.alternate, before, after, options);\n      }\n\n      break;\n\n    case 'EachOf':\n      if (ast.block) {\n        ast.block = walkAST(ast.block, before, after, options);\n      }\n\n      break;\n\n    case 'Conditional':\n      if (ast.consequent) {\n        ast.consequent = walkAST(ast.consequent, before, after, options);\n      }\n\n      if (ast.alternate) {\n        ast.alternate = walkAST(ast.alternate, before, after, options);\n      }\n\n      break;\n\n    case 'Include':\n      walkAST(ast.block, before, after, options);\n      walkAST(ast.file, before, after, options);\n      break;\n\n    case 'Extends':\n      walkAST(ast.file, before, after, options);\n      break;\n\n    case 'RawInclude':\n      ast.filters = walkAndMergeNodes(ast.filters);\n      walkAST(ast.file, before, after, options);\n      break;\n\n    case 'Attrs':\n    case 'BlockComment':\n    case 'Comment':\n    case 'Doctype':\n    case 'IncludeFilter':\n    case 'MixinBlock':\n    case 'YieldBlock':\n    case 'Text':\n      break;\n\n    case 'FileReference':\n      if (options.includeDependencies && ast.ast) {\n        walkAST(ast.ast, before, after, options);\n      }\n\n      break;\n\n    default:\n      throw new Error('Unexpected node type ' + ast.type);\n      break;\n  }\n\n  parents.shift();\n  after && after(ast, replace);\n  return ast;\n\n  function walkAndMergeNodes(nodes) {\n    return nodes.reduce(function (nodes, node) {\n      var result = walkAST(node, before, after, options);\n\n      if (Array.isArray(result)) {\n        return nodes.concat(result);\n      } else {\n        return nodes.concat([result]);\n      }\n    }, []);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}