{"ast":null,"code":"'use strict';\n\nvar dirname = require('path').dirname;\n\nvar constantinople = require('constantinople');\n\nvar walk = require('pug-walk');\n\nvar error = require('pug-error');\n\nvar runFilter = require('./run-filter');\n\nmodule.exports = handleFilters;\n\nfunction handleFilters(ast, filters, options, filterAliases) {\n  options = options || {};\n  walk(ast, function (node) {\n    var dir = node.filename ? dirname(node.filename) : null;\n\n    if (node.type === 'Filter') {\n      handleNestedFilters(node, filters, options, filterAliases);\n      var text = getBodyAsText(node);\n      var attrs = getAttributes(node, options);\n      attrs.filename = node.filename;\n      node.type = 'Text';\n      node.val = filterWithFallback(node, text, attrs);\n    } else if (node.type === 'RawInclude' && node.filters.length) {\n      var firstFilter = node.filters.pop();\n      var attrs = getAttributes(firstFilter, options);\n      var filename = attrs.filename = node.file.fullPath;\n      node.type = 'Text';\n      node.val = filterFileWithFallback(firstFilter, filename, node.file, attrs);\n      node.filters.slice().reverse().forEach(function (filter) {\n        var attrs = getAttributes(filter, options);\n        attrs.filename = filename;\n        node.val = filterWithFallback(filter, node.val, attrs);\n      });\n      node.filters = undefined;\n      node.file = undefined;\n    }\n\n    function filterWithFallback(filter, text, attrs, funcName) {\n      try {\n        var filterName = getFilterName(filter);\n\n        if (filters && filters[filterName]) {\n          return filters[filterName](text, attrs);\n        } else {\n          return runFilter(filterName, text, attrs, dir, funcName);\n        }\n      } catch (ex) {\n        if (ex.code === 'UNKNOWN_FILTER') {\n          throw error(ex.code, ex.message, filter);\n        }\n\n        throw ex;\n      }\n    }\n\n    function filterFileWithFallback(filter, filename, file, attrs) {\n      var filterName = getFilterName(filter);\n\n      if (filters && filters[filterName]) {\n        if (filters[filterName].renderBuffer) {\n          return filters[filterName].renderBuffer(file.raw, attrs);\n        } else {\n          return filters[filterName](file.str, attrs);\n        }\n      } else {\n        return filterWithFallback(filter, filename, attrs, 'renderFile');\n      }\n    }\n  }, {\n    includeDependencies: true\n  });\n\n  function getFilterName(filter) {\n    var filterName = filter.name;\n\n    if (filterAliases && filterAliases[filterName]) {\n      filterName = filterAliases[filterName];\n\n      if (filterAliases[filterName]) {\n        throw error('FILTER_ALISE_CHAIN', 'The filter \"' + filter.name + '\" is an alias for \"' + filterName + '\", which is an alias for \"' + filterAliases[filterName] + '\".  Pug does not support chains of filter aliases.', filter);\n      }\n    }\n\n    return filterName;\n  }\n\n  return ast;\n}\n\nfunction handleNestedFilters(node, filters, options, filterAliases) {\n  if (node.block.nodes[0] && node.block.nodes[0].type === 'Filter') {\n    node.block.nodes[0] = handleFilters(node.block, filters, options, filterAliases).nodes[0];\n  }\n}\n\nfunction getBodyAsText(node) {\n  return node.block.nodes.map(function (node) {\n    return node.val;\n  }).join('');\n}\n\nfunction getAttributes(node, options) {\n  var attrs = {};\n  node.attrs.forEach(function (attr) {\n    try {\n      attrs[attr.name] = attr.val === true ? true : constantinople.toConstant(attr.val);\n    } catch (ex) {\n      if (/not constant/.test(ex.message)) {\n        throw error('FILTER_OPTION_NOT_CONSTANT', ex.message + ' All filters are rendered compile-time so filter options must be constants.', node);\n      }\n\n      throw ex;\n    }\n  });\n  var opts = options[node.name] || {};\n  Object.keys(opts).forEach(function (opt) {\n    if (!attrs.hasOwnProperty(opt)) {\n      attrs[opt] = opts[opt];\n    }\n  });\n  return attrs;\n}","map":null,"metadata":{},"sourceType":"script"}