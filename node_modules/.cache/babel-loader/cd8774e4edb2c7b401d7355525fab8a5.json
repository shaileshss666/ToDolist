{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar TokenStream = require('token-stream');\n\nvar _error = require('pug-error');\n\nvar inlineTags = require('./lib/inline-tags');\n\nmodule.exports = parse;\nmodule.exports.Parser = Parser;\n\nfunction parse(tokens, options) {\n  var parser = new Parser(tokens, options);\n  var ast = parser.parse();\n  return JSON.parse(JSON.stringify(ast));\n}\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\n\nfunction Parser(tokens, options) {\n  options = options || {};\n\n  if (!Array.isArray(tokens)) {\n    throw new Error('Expected tokens to be an Array but got \"' + typeof tokens + '\"');\n  }\n\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + typeof options + '\"');\n  }\n\n  this.tokens = new TokenStream(tokens);\n  this.filename = options.filename;\n  this.src = options.src;\n  this.inMixin = 0;\n  this.plugins = options.plugins || [];\n}\n/**\n * Parser prototype.\n */\n\n\nParser.prototype = {\n  /**\n   * Save original constructor\n   */\n  constructor: Parser,\n  error: function error(code, message, token) {\n    var err = _error(code, message, {\n      line: token.loc.start.line,\n      column: token.loc.start.column,\n      filename: this.filename,\n      src: this.src\n    });\n\n    throw err;\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  advance: function advance() {\n    return this.tokens.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  peek: function peek() {\n    return this.tokens.peek();\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  lookahead: function lookahead(n) {\n    return this.tokens.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n  parse: function parse() {\n    var block = this.emptyBlock(0);\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n\n        if (expr) {\n          if (expr.type === 'Block') {\n            block.nodes = block.nodes.concat(expr.nodes);\n          } else {\n            block.nodes.push(expr);\n          }\n        }\n      }\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n  expect: function expect(type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      this.error('INVALID_TOKEN', 'expected \"' + type + '\", but got \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n  accept: function accept(type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n  initBlock: function initBlock(line, nodes) {\n    /* istanbul ignore if */\n    if ((line | 0) !== line) throw new Error('`line` is not an integer');\n    /* istanbul ignore if */\n\n    if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');\n    return {\n      type: 'Block',\n      nodes: nodes,\n      line: line,\n      filename: this.filename\n    };\n  },\n  emptyBlock: function emptyBlock(line) {\n    return this.initBlock(line, []);\n  },\n  runPlugin: function runPlugin(context, tok) {\n    var rest = [this];\n\n    for (var i = 2; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n\n    var pluginContext;\n\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n\n      if (plugin[context] && plugin[context][tok.type]) {\n        if (pluginContext) throw new Error('Multiple plugin handlers found for context ' + JSON.stringify(context) + ', token type ' + JSON.stringify(tok.type));\n        pluginContext = plugin[context];\n      }\n    }\n\n    if (pluginContext) return pluginContext[tok.type].apply(pluginContext, rest);\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | text-html\n   * | dot\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n  parseExpr: function parseExpr() {\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n\n      case 'mixin':\n        return this.parseMixin();\n\n      case 'block':\n        return this.parseBlock();\n\n      case 'mixin-block':\n        return this.parseMixinBlock();\n\n      case 'case':\n        return this.parseCase();\n\n      case 'extends':\n        return this.parseExtends();\n\n      case 'include':\n        return this.parseInclude();\n\n      case 'doctype':\n        return this.parseDoctype();\n\n      case 'filter':\n        return this.parseFilter();\n\n      case 'comment':\n        return this.parseComment();\n\n      case 'text':\n      case 'interpolated-code':\n      case 'start-pug-interpolation':\n        return this.parseText({\n          block: true\n        });\n\n      case 'text-html':\n        return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());\n\n      case 'dot':\n        return this.parseDot();\n\n      case 'each':\n        return this.parseEach();\n\n      case 'eachOf':\n        return this.parseEachOf();\n\n      case 'code':\n        return this.parseCode();\n\n      case 'blockcode':\n        return this.parseBlockCode();\n\n      case 'if':\n        return this.parseConditional();\n\n      case 'while':\n        return this.parseWhile();\n\n      case 'call':\n        return this.parseCall();\n\n      case 'interpolation':\n        return this.parseInterpolation();\n\n      case 'yield':\n        return this.parseYield();\n\n      case 'id':\n      case 'class':\n        if (!this.peek().loc.start) debugger;\n        this.tokens.defer({\n          type: 'tag',\n          val: 'div',\n          loc: this.peek().loc,\n          filename: this.filename\n        });\n        return this.parseExpr();\n\n      default:\n        var pluginResult = this.runPlugin('expressionTokens', this.peek());\n        if (pluginResult) return pluginResult;\n        this.error('INVALID_TOKEN', 'unexpected token \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n  parseDot: function parseDot() {\n    this.advance();\n    return this.parseTextBlock();\n  },\n\n  /**\n   * Text\n   */\n  parseText: function parseText(options) {\n    var tags = [];\n    var lineno = this.peek().loc.start.line;\n    var nextTok = this.peek();\n\n    loop: while (true) {\n      switch (nextTok.type) {\n        case 'text':\n          var tok = this.advance();\n          tags.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'interpolated-code':\n          var tok = this.advance();\n          tags.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'newline':\n          if (!options || !options.block) break loop;\n          var tok = this.advance();\n          var nextType = this.peek().type;\n\n          if (nextType === 'text' || nextType === 'interpolated-code') {\n            tags.push({\n              type: 'Text',\n              val: '\\n',\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n          }\n\n          break;\n\n        case 'start-pug-interpolation':\n          this.advance();\n          tags.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('textTokens', nextTok, tags);\n          if (pluginResult) break;\n          break loop;\n      }\n\n      nextTok = this.peek();\n    }\n\n    if (tags.length === 1) return tags[0];else return this.initBlock(lineno, tags);\n  },\n  parseTextHtml: function parseTextHtml() {\n    var nodes = [];\n    var currentNode = null;\n\n    loop: while (true) {\n      switch (this.peek().type) {\n        case 'text-html':\n          var text = this.advance();\n\n          if (!currentNode) {\n            currentNode = {\n              type: 'Text',\n              val: text.val,\n              filename: this.filename,\n              line: text.loc.start.line,\n              column: text.loc.start.column,\n              isHtml: true\n            };\n            nodes.push(currentNode);\n          } else {\n            currentNode.val += '\\n' + text.val;\n          }\n\n          break;\n\n        case 'indent':\n          var block = this.block();\n          block.nodes.forEach(function (node) {\n            if (node.isHtml) {\n              if (!currentNode) {\n                currentNode = node;\n                nodes.push(currentNode);\n              } else {\n                currentNode.val += '\\n' + node.val;\n              }\n            } else {\n              currentNode = null;\n              nodes.push(node);\n            }\n          });\n          break;\n\n        case 'code':\n          currentNode = null;\n          nodes.push(this.parseCode(true));\n          break;\n\n        case 'newline':\n          this.advance();\n          break;\n\n        default:\n          break loop;\n      }\n    }\n\n    return nodes;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n  parseBlockExpansion: function parseBlockExpansion() {\n    var tok = this.accept(':');\n\n    if (tok) {\n      var expr = this.parseExpr();\n      return expr.type === 'Block' ? expr : this.initBlock(tok.loc.start.line, [expr]);\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n  parseCase: function parseCase() {\n    var tok = this.expect('case');\n    var node = {\n      type: 'Case',\n      expr: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var block = this.emptyBlock(tok.loc.start.line + 1);\n    this.expect('indent');\n\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'comment':\n        case 'newline':\n          this.advance();\n          break;\n\n        case 'when':\n          block.nodes.push(this.parseWhen());\n          break;\n\n        case 'default':\n          block.nodes.push(this.parseDefault());\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('caseTokens', this.peek(), block);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token \"' + this.peek().type + '\", expected \"when\", \"default\" or \"newline\"', this.peek());\n      }\n    }\n\n    this.expect('outdent');\n    node.block = block;\n    return node;\n  },\n\n  /**\n   * when\n   */\n  parseWhen: function parseWhen() {\n    var tok = this.expect('when');\n\n    if (this.peek().type !== 'newline') {\n      return {\n        type: 'When',\n        expr: tok.val,\n        block: this.parseBlockExpansion(),\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'When',\n        expr: tok.val,\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * default\n   */\n  parseDefault: function parseDefault() {\n    var tok = this.expect('default');\n    return {\n      type: 'When',\n      expr: 'default',\n      block: this.parseBlockExpansion(),\n      debug: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * code\n   */\n  parseCode: function parseCode(noBlock) {\n    var tok = this.expect('code');\n    assert(typeof tok.mustEscape === 'boolean', 'Please update to the newest version of pug-lexer.');\n    var node = {\n      type: 'Code',\n      val: tok.val,\n      buffer: tok.buffer,\n      mustEscape: tok.mustEscape !== false,\n      isInline: !!noBlock,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // todo: why is this here?  It seems like a hacky workaround\n\n    if (node.val.match(/^ *else/)) node.debug = false;\n    if (noBlock) return node;\n    var block; // handle block\n\n    block = 'indent' == this.peek().type;\n\n    if (block) {\n      if (tok.buffer) {\n        this.error('BLOCK_IN_BUFFERED_CODE', 'Buffered code cannot have a block attached to it', this.peek());\n      }\n\n      node.block = this.block();\n    }\n\n    return node;\n  },\n  parseConditional: function parseConditional() {\n    var tok = this.expect('if');\n    var node = {\n      type: 'Conditional',\n      test: tok.val,\n      consequent: this.emptyBlock(tok.loc.start.line),\n      alternate: null,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // handle block\n\n    if ('indent' == this.peek().type) {\n      node.consequent = this.block();\n    }\n\n    var currentNode = node;\n\n    while (true) {\n      if (this.peek().type === 'newline') {\n        this.expect('newline');\n      } else if (this.peek().type === 'else-if') {\n        tok = this.expect('else-if');\n        currentNode = currentNode.alternate = {\n          type: 'Conditional',\n          test: tok.val,\n          consequent: this.emptyBlock(tok.loc.start.line),\n          alternate: null,\n          line: tok.loc.start.line,\n          column: tok.loc.start.column,\n          filename: this.filename\n        };\n\n        if ('indent' == this.peek().type) {\n          currentNode.consequent = this.block();\n        }\n      } else if (this.peek().type === 'else') {\n        this.expect('else');\n\n        if (this.peek().type === 'indent') {\n          currentNode.alternate = this.block();\n        }\n\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  },\n  parseWhile: function parseWhile() {\n    var tok = this.expect('while');\n    var node = {\n      type: 'While',\n      test: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // handle block\n\n    if ('indent' == this.peek().type) {\n      node.block = this.block();\n    } else {\n      node.block = this.emptyBlock(tok.loc.start.line);\n    }\n\n    return node;\n  },\n\n  /**\n   * block code\n   */\n  parseBlockCode: function parseBlockCode() {\n    var tok = this.expect('blockcode');\n    var line = tok.loc.start.line;\n    var column = tok.loc.start.column;\n    var body = this.peek();\n    var text = '';\n\n    if (body.type === 'start-pipeless-text') {\n      this.advance();\n\n      while (this.peek().type !== 'end-pipeless-text') {\n        tok = this.advance();\n\n        switch (tok.type) {\n          case 'text':\n            text += tok.val;\n            break;\n\n          case 'newline':\n            text += '\\n';\n            break;\n\n          default:\n            var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);\n\n            if (pluginResult) {\n              text += pluginResult;\n              break;\n            }\n\n            this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n        }\n      }\n\n      this.advance();\n    }\n\n    return {\n      type: 'Code',\n      val: text,\n      buffer: false,\n      mustEscape: false,\n      isInline: false,\n      line: line,\n      column: column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * comment\n   */\n  parseComment: function parseComment() {\n    var tok = this.expect('comment');\n    var block;\n\n    if (block = this.parseTextBlock()) {\n      return {\n        type: 'BlockComment',\n        val: tok.val,\n        block: block,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'Comment',\n        val: tok.val,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * doctype\n   */\n  parseDoctype: function parseDoctype() {\n    var tok = this.expect('doctype');\n    return {\n      type: 'Doctype',\n      val: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n  parseIncludeFilter: function parseIncludeFilter() {\n    var tok = this.expect('filter');\n    var attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    return {\n      type: 'IncludeFilter',\n      name: tok.val,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n  parseFilter: function parseFilter() {\n    var tok = this.expect('filter');\n    var block,\n        attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    if (this.peek().type === 'text') {\n      var textToken = this.advance();\n      block = this.initBlock(textToken.loc.start.line, [{\n        type: 'Text',\n        val: textToken.val,\n        line: textToken.loc.start.line,\n        column: textToken.loc.start.column,\n        filename: this.filename\n      }]);\n    } else if (this.peek().type === 'filter') {\n      block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);\n    } else {\n      block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);\n    }\n\n    return {\n      type: 'Filter',\n      name: tok.val,\n      block: block,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * each block\n   */\n  parseEach: function parseEach() {\n    var tok = this.expect('each');\n    var node = {\n      type: 'Each',\n      obj: tok.code,\n      val: tok.val,\n      key: tok.key,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    if (this.peek().type == 'else') {\n      this.advance();\n      node.alternate = this.block();\n    }\n\n    return node;\n  },\n  parseEachOf: function parseEachOf() {\n    var tok = this.expect('eachOf');\n    var node = {\n      type: 'EachOf',\n      obj: tok.code,\n      val: tok.val,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n  parseExtends: function parseExtends() {\n    var tok = this.expect('extends');\n    var path = this.expect('path');\n    return {\n      type: 'Extends',\n      file: {\n        type: 'FileReference',\n        path: path.val.trim(),\n        line: path.loc.start.line,\n        column: path.loc.start.column,\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * 'block' name block\n   */\n  parseBlock: function parseBlock() {\n    var tok = this.expect('block');\n    var node = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n    node.type = 'NamedBlock';\n    node.name = tok.val.trim();\n    node.mode = tok.mode;\n    node.line = tok.loc.start.line;\n    node.column = tok.loc.start.column;\n    return node;\n  },\n  parseMixinBlock: function parseMixinBlock() {\n    var tok = this.expect('mixin-block');\n\n    if (!this.inMixin) {\n      this.error('BLOCK_OUTISDE_MIXIN', 'Anonymous blocks are not allowed unless they are part of a mixin.', tok);\n    }\n\n    return {\n      type: 'MixinBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n  parseYield: function parseYield() {\n    var tok = this.expect('yield');\n    return {\n      type: 'YieldBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * include block?\n   */\n  parseInclude: function parseInclude() {\n    var tok = this.expect('include');\n    var node = {\n      type: 'Include',\n      file: {\n        type: 'FileReference',\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var filters = [];\n\n    while (this.peek().type === 'filter') {\n      filters.push(this.parseIncludeFilter());\n    }\n\n    var path = this.expect('path');\n    node.file.path = path.val.trim();\n    node.file.line = path.loc.start.line;\n    node.file.column = path.loc.start.column;\n\n    if ((/\\.jade$/.test(node.file.path) || /\\.pug$/.test(node.file.path)) && !filters.length) {\n      node.block = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n\n      if (/\\.jade$/.test(node.file.path)) {\n        console.warn(this.filename + ', line ' + tok.loc.start.line + ':\\nThe .jade extension is deprecated, use .pug for \"' + node.file.path + '\".');\n      }\n    } else {\n      node.type = 'RawInclude';\n      node.filters = filters;\n\n      if (this.peek().type === 'indent') {\n        this.error('RAW_INCLUDE_BLOCK', 'Raw inclusion cannot contain a block', this.peek());\n      }\n    }\n\n    return node;\n  },\n\n  /**\n   * call ident block\n   */\n  parseCall: function parseCall() {\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = {\n      type: 'Mixin',\n      name: name,\n      args: args,\n      block: this.emptyBlock(tok.loc.start.line),\n      call: true,\n      attrs: [],\n      attributeBlocks: [],\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    this.tag(mixin);\n\n    if (mixin.code) {\n      mixin.block.nodes.push(mixin.code);\n      delete mixin.code;\n    }\n\n    if (mixin.block.nodes.length === 0) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n  parseMixin: function parseMixin() {\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n\n    if ('indent' == this.peek().type) {\n      this.inMixin++;\n      var mixin = {\n        type: 'Mixin',\n        name: name,\n        args: args,\n        block: this.block(),\n        call: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n      this.inMixin--;\n      return mixin;\n    } else {\n      this.error('MIXIN_WITHOUT_BODY', 'Mixin ' + name + ' declared without body', tok);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n  parseTextBlock: function parseTextBlock() {\n    var tok = this.accept('start-pipeless-text');\n    if (!tok) return;\n    var block = this.emptyBlock(tok.loc.start.line);\n\n    while (this.peek().type !== 'end-pipeless-text') {\n      var tok = this.advance();\n\n      switch (tok.type) {\n        case 'text':\n          block.nodes.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'newline':\n          block.nodes.push({\n            type: 'Text',\n            val: '\\n',\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'start-pug-interpolation':\n          block.nodes.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n\n        case 'interpolated-code':\n          block.nodes.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('textBlockTokens', tok, block, tok);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n      }\n    }\n\n    this.advance();\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n  block: function block() {\n    var tok = this.expect('indent');\n    var block = this.emptyBlock(tok.loc.start.line);\n\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n\n        if (expr.type === 'Block') {\n          block.nodes = block.nodes.concat(expr.nodes);\n        } else {\n          block.nodes.push(expr);\n        }\n      }\n    }\n\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  parseInterpolation: function parseInterpolation() {\n    var tok = this.advance();\n    var tag = {\n      type: 'InterpolatedTag',\n      expr: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return this.tag(tag, {\n      selfClosingAllowed: true\n    });\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  parseTag: function parseTag() {\n    var tok = this.advance();\n    var tag = {\n      type: 'Tag',\n      name: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: inlineTags.indexOf(tok.val) !== -1,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return this.tag(tag, {\n      selfClosingAllowed: true\n    });\n  },\n\n  /**\n   * Parse tag.\n   */\n  tag: function tag(_tag, options) {\n    var seenAttrs = false;\n    var attributeNames = [];\n    var selfClosingAllowed = options && options.selfClosingAllowed; // (attrs | class | id)*\n\n    out: while (true) {\n      switch (this.peek().type) {\n        case 'id':\n        case 'class':\n          var tok = this.advance();\n\n          if (tok.type === 'id') {\n            if (attributeNames.indexOf('id') !== -1) {\n              this.error('DUPLICATE_ID', 'Duplicate attribute \"id\" is not allowed.', tok);\n            }\n\n            attributeNames.push('id');\n          }\n\n          _tag.attrs.push({\n            name: tok.type,\n            val: \"'\" + tok.val + \"'\",\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n            mustEscape: false\n          });\n\n          continue;\n\n        case 'start-attributes':\n          if (seenAttrs) {\n            console.warn(this.filename + ', line ' + this.peek().loc.start.line + ':\\nYou should not have pug tags with multiple attributes.');\n          }\n\n          seenAttrs = true;\n          _tag.attrs = _tag.attrs.concat(this.attrs(attributeNames));\n          continue;\n\n        case '&attributes':\n          var tok = this.advance();\n\n          _tag.attributeBlocks.push({\n            type: 'AttributeBlock',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('tagAttributeTokens', this.peek(), _tag, attributeNames);\n          if (pluginResult) break;\n          break out;\n      }\n    } // check immediate '.'\n\n\n    if ('dot' == this.peek().type) {\n      _tag.textOnly = true;\n      this.advance();\n    } // (text | code | ':')?\n\n\n    switch (this.peek().type) {\n      case 'text':\n      case 'interpolated-code':\n        var text = this.parseText();\n\n        if (text.type === 'Block') {\n          _tag.block.nodes.push.apply(_tag.block.nodes, text.nodes);\n        } else {\n          _tag.block.nodes.push(text);\n        }\n\n        break;\n\n      case 'code':\n        _tag.block.nodes.push(this.parseCode(true));\n\n        break;\n\n      case ':':\n        this.advance();\n        var expr = this.parseExpr();\n        _tag.block = expr.type === 'Block' ? expr : this.initBlock(_tag.line, [expr]);\n        break;\n\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'start-pipeless-text':\n      case 'end-pug-interpolation':\n        break;\n\n      case 'slash':\n        if (selfClosingAllowed) {\n          this.advance();\n          _tag.selfClosing = true;\n          break;\n        }\n\n      default:\n        var pluginResult = this.runPlugin('tagTokens', this.peek(), _tag, options);\n        if (pluginResult) break;\n        this.error('INVALID_TOKEN', 'Unexpected token `' + this.peek().type + '` expected `text`, `interpolated-code`, `code`, `:`' + (selfClosingAllowed ? ', `slash`' : '') + ', `newline` or `eos`', this.peek());\n    } // newline*\n\n\n    while ('newline' == this.peek().type) {\n      this.advance();\n    } // block?\n\n\n    if (_tag.textOnly) {\n      _tag.block = this.parseTextBlock() || this.emptyBlock(_tag.line);\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        _tag.block.nodes.push(block.nodes[i]);\n      }\n    }\n\n    return _tag;\n  },\n  attrs: function attrs(attributeNames) {\n    this.expect('start-attributes');\n    var attrs = [];\n    var tok = this.advance();\n\n    while (tok.type === 'attribute') {\n      if (tok.name !== 'class' && attributeNames) {\n        if (attributeNames.indexOf(tok.name) !== -1) {\n          this.error('DUPLICATE_ATTRIBUTE', 'Duplicate attribute \"' + tok.name + '\" is not allowed.', tok);\n        }\n\n        attributeNames.push(tok.name);\n      }\n\n      attrs.push({\n        name: tok.name,\n        val: tok.val,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n        mustEscape: tok.mustEscape !== false\n      });\n      tok = this.advance();\n    }\n\n    this.tokens.defer(tok);\n    this.expect('end-attributes');\n    return attrs;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}