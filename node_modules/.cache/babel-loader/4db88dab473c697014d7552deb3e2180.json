{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar assert = require('assert');\n\nvar Promise = require('promise');\n\nvar isPromise = require('is-promise');\n\nvar tr = module.exports = function (transformer) {\n  return new Transformer(transformer);\n};\n\ntr.Transformer = Transformer;\ntr.normalizeFn = normalizeFn;\ntr.normalizeFnAsync = normalizeFnAsync;\ntr.normalize = normalize;\ntr.normalizeAsync = normalizeAsync;\n\nif (fs.readFile) {\n  tr.readFile = Promise.denodeify(fs.readFile);\n  tr.readFileSync = fs.readFileSync;\n} else {\n  tr.readFile = function () {\n    throw new Error('fs.readFile unsupported');\n  };\n\n  tr.readFileSync = function () {\n    throw new Error('fs.readFileSync unsupported');\n  };\n}\n\nfunction normalizeFn(result) {\n  if (typeof result === 'function') {\n    return {\n      fn: result,\n      dependencies: []\n    };\n  } else if (result && typeof result === 'object' && typeof result.fn === 'function') {\n    if ('dependencies' in result) {\n      if (!Array.isArray(result.dependencies)) {\n        throw new Error('Result should have a dependencies property that is an array');\n      }\n    } else {\n      result.dependencies = [];\n    }\n\n    return result;\n  } else {\n    throw new Error('Invalid result object from transform.');\n  }\n}\n\nfunction normalizeFnAsync(result, cb) {\n  return Promise.resolve(result).then(function (result) {\n    if (result && isPromise(result.fn)) {\n      return result.fn.then(function (fn) {\n        result.fn = fn;\n        return result;\n      });\n    }\n\n    return result;\n  }).then(tr.normalizeFn).nodeify(cb);\n}\n\nfunction normalize(result) {\n  if (typeof result === 'string') {\n    return {\n      body: result,\n      dependencies: []\n    };\n  } else if (result && typeof result === 'object' && typeof result.body === 'string') {\n    if ('dependencies' in result) {\n      if (!Array.isArray(result.dependencies)) {\n        throw new Error('Result should have a dependencies property that is an array');\n      }\n    } else {\n      result.dependencies = [];\n    }\n\n    return result;\n  } else {\n    throw new Error('Invalid result object from transform.');\n  }\n}\n\nfunction normalizeAsync(result, cb) {\n  return Promise.resolve(result).then(function (result) {\n    if (result && isPromise(result.body)) {\n      return result.body.then(function (body) {\n        result.body = body;\n        return result;\n      });\n    }\n\n    return result;\n  }).then(tr.normalize).nodeify(cb);\n}\n\nfunction Transformer(tr) {\n  assert(tr, 'Transformer must be an object');\n  assert(typeof tr.name === 'string', 'Transformer must have a name');\n  assert(typeof tr.outputFormat === 'string', 'Transformer must have an output format');\n  assert(['compile', 'compileAsync', 'compileFile', 'compileFileAsync', 'compileClient', 'compileClientAsync', 'compileFileClient', 'compileFileClientAsync', 'render', 'renderAsync', 'renderFile', 'renderFileAsync'].some(function (method) {\n    return typeof tr[method] === 'function';\n  }), 'Transformer must implement at least one of the potential methods.');\n  this._tr = tr;\n  this.name = this._tr.name;\n  this.outputFormat = this._tr.outputFormat;\n  this.inputFormats = this._tr.inputFormats || [this.name];\n}\n\nvar fallbacks = {\n  compile: ['compile', 'render'],\n  compileAsync: ['compileAsync', 'compile', 'render'],\n  compileFile: ['compileFile', 'compile', 'renderFile', 'render'],\n  compileFileAsync: ['compileFileAsync', 'compileFile', 'compileAsync', 'compile', 'renderFile', 'render'],\n  compileClient: ['compileClient'],\n  compileClientAsync: ['compileClientAsync', 'compileClient'],\n  compileFileClient: ['compileFileClient', 'compileClient'],\n  compileFileClientAsync: ['compileFileClientAsync', 'compileFileClient', 'compileClientAsync', 'compileClient'],\n  render: ['render', 'compile'],\n  renderAsync: ['renderAsync', 'render', 'compileAsync', 'compile'],\n  renderFile: ['renderFile', 'render', 'compileFile', 'compile'],\n  renderFileAsync: ['renderFileAsync', 'renderFile', 'renderAsync', 'render', 'compileFileAsync', 'compileFile', 'compileAsync', 'compile']\n};\n\nTransformer.prototype._hasMethod = function (method) {\n  return typeof this._tr[method] === 'function';\n};\n\nTransformer.prototype.can = function (method) {\n  return fallbacks[method].some(function (method) {\n    return this._hasMethod(method);\n  }.bind(this));\n};\n/* COMPILE */\n\n\nTransformer.prototype.compile = function (str, options) {\n  if (!this._hasMethod('compile')) {\n    if (this.can('render')) {\n      var _this = this;\n\n      return {\n        fn: function fn(locals) {\n          return tr.normalize(_this._tr.render(str, options, locals)).body;\n        },\n        dependencies: []\n      };\n    }\n\n    if (this.can('compileAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support synchronous compilation');\n    } else if (this.can('compileFileAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support compiling plain strings');\n    } else {\n      throw new Error('The Transform \"' + this.name + '\" does not support compilation');\n    }\n  }\n\n  return tr.normalizeFn(this._tr.compile(str, options));\n};\n\nTransformer.prototype.compileAsync = function (str, options, cb) {\n  if (!this.can('compileAsync')) {\n    // compileFile* || renderFile* || renderAsync || compile*Client*\n    return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support compiling plain strings')).nodeify(cb);\n  }\n\n  if (this._hasMethod('compileAsync')) {\n    return tr.normalizeFnAsync(this._tr.compileAsync(str, options), cb);\n  } else {\n    // render || compile\n    return tr.normalizeFnAsync(this.compile(str, options), cb);\n  }\n};\n\nTransformer.prototype.compileFile = function (filename, options) {\n  if (!this.can('compileFile')) {\n    // compile*Client* || compile*Async || render*Async\n    throw new Error('The Transform \"' + this.name + '\" does not support synchronous compilation');\n  }\n\n  if (this._hasMethod('compileFile')) {\n    return tr.normalizeFn(this._tr.compileFile(filename, options));\n  } else if (this._hasMethod('renderFile')) {\n    return tr.normalizeFn(function (locals) {\n      return tr.normalize(this._tr.renderFile(filename, options, locals)).body;\n    }.bind(this));\n  } else {\n    // render || compile\n    if (!options) options = {};\n    if (options.filename === undefined) options.filename = filename;\n    return this.compile(tr.readFileSync(filename, 'utf8'), options);\n  }\n};\n\nTransformer.prototype.compileFileAsync = function (filename, options, cb) {\n  if (!this.can('compileFileAsync')) {\n    return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support compilation'));\n  }\n\n  if (this._hasMethod('compileFileAsync')) {\n    return tr.normalizeFnAsync(this._tr.compileFileAsync(filename, options), cb);\n  } else if (this._hasMethod('compileFile') || this._hasMethod('renderFile')) {\n    return tr.normalizeFnAsync(this.compileFile(filename, options), cb);\n  } else {\n    // compileAsync || compile || render\n    if (!options) options = {};\n    if (options.filename === undefined) options.filename = filename;\n    return tr.normalizeFnAsync(tr.readFile(filename, 'utf8').then(function (str) {\n      if (this._hasMethod('compileAsync')) {\n        return this._tr.compileAsync(str, options);\n      } else {\n        // compile || render\n        return this.compile(str, options);\n      }\n    }.bind(this)), cb);\n  }\n};\n/* COMPILE CLIENT */\n\n\nTransformer.prototype.compileClient = function (str, options) {\n  if (!this.can('compileClient')) {\n    if (this.can('compileClientAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support compiling for the client synchronously.');\n    } else if (this.can('compileFileClientAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support compiling for the client from a string.');\n    } else {\n      throw new Error('The Transform \"' + this.name + '\" does not support compiling for the client');\n    }\n  }\n\n  return tr.normalize(this._tr.compileClient(str, options));\n};\n\nTransformer.prototype.compileClientAsync = function (str, options, cb) {\n  if (!this.can('compileClientAsync')) {\n    if (this.can('compileFileClientAsync')) {\n      return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support compiling for the client from a string.')).nodeify(cb);\n    } else {\n      return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support compiling for the client')).nodeify(cb);\n    }\n  }\n\n  if (this._hasMethod('compileClientAsync')) {\n    return tr.normalizeAsync(this._tr.compileClientAsync(str, options), cb);\n  } else {\n    return tr.normalizeAsync(this._tr.compileClient(str, options), cb);\n  }\n};\n\nTransformer.prototype.compileFileClient = function (filename, options) {\n  if (!this.can('compileFileClient')) {\n    if (this.can('compileFileClientAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support compiling for the client synchronously.');\n    } else {\n      throw new Error('The Transform \"' + this.name + '\" does not support compiling for the client');\n    }\n  }\n\n  if (this._hasMethod('compileFileClient')) {\n    return tr.normalize(this._tr.compileFileClient(filename, options));\n  } else {\n    if (!options) options = {};\n    if (options.filename === undefined) options.filename = filename;\n    return tr.normalize(this._tr.compileClient(tr.readFileSync(filename, 'utf8'), options));\n  }\n};\n\nTransformer.prototype.compileFileClientAsync = function (filename, options, cb) {\n  if (!this.can('compileFileClientAsync')) {\n    return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support compiling for the client')).nodeify(cb);\n  }\n\n  if (this._hasMethod('compileFileClientAsync')) {\n    return tr.normalizeAsync(this._tr.compileFileClientAsync(filename, options), cb);\n  } else if (this._hasMethod('compileFileClient')) {\n    return tr.normalizeAsync(this._tr.compileFileClient(filename, options), cb);\n  } else {\n    if (!options) options = {};\n    if (options.filename === undefined) options.filename = filename;\n    return tr.normalizeAsync(tr.readFile(filename, 'utf8').then(function (str) {\n      if (this._hasMethod('compileClientAsync')) {\n        return this._tr.compileClientAsync(str, options);\n      } else {\n        return this._tr.compileClient(str, options);\n      }\n    }.bind(this)), cb);\n  }\n};\n/* RENDER */\n\n\nTransformer.prototype.render = function (str, options, locals) {\n  if (!this.can('render')) {\n    if (this.can('renderAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support rendering synchronously.');\n    } else if (this.can('renderFileAsync')) {\n      throw new Error('The Transform \"' + this.name + '\" does not support rendering from a string.');\n    } else {\n      throw new Error('The Transform \"' + this.name + '\" does not support rendering');\n    }\n  }\n\n  if (this._hasMethod('render')) {\n    return tr.normalize(this._tr.render(str, options, locals));\n  } else {\n    var compiled = tr.normalizeFn(this._tr.compile(str, options));\n    var body = compiled.fn(locals || options);\n\n    if (typeof body !== 'string') {\n      throw new Error('The Transform \"' + this.name + '\" does not support rendering synchronously.');\n    }\n\n    return tr.normalize({\n      body: body,\n      dependencies: compiled.dependencies\n    });\n  }\n};\n\nTransformer.prototype.renderAsync = function (str, options, locals, cb) {\n  if (typeof locals === 'function') {\n    cb = locals;\n    locals = options;\n  }\n\n  if (!this.can('renderAsync')) {\n    if (this.can('renderFileAsync')) {\n      return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support rendering from a string.')).nodeify(cb);\n    } else {\n      return Promise.reject(new Error('The Transform \"' + this.name + '\" does not support rendering')).nodeify(cb);\n    }\n  }\n\n  if (this._hasMethod('renderAsync')) {\n    return tr.normalizeAsync(this._tr.renderAsync(str, options, locals), cb);\n  } else if (this._hasMethod('render')) {\n    return tr.normalizeAsync(this._tr.render(str, options, locals), cb);\n  } else {\n    return tr.normalizeAsync(this.compileAsync(str, options).then(function (compiled) {\n      return {\n        body: compiled.fn(locals || options),\n        dependencies: compiled.dependencies\n      };\n    }), cb);\n  }\n};\n\nTransformer.prototype.renderFile = function (filename, options, locals) {\n  if (!this.can('renderFile')) {\n    // *Async, *Client\n    throw new Error('The Transform \"' + this.name + '\" does not support rendering synchronously.');\n  }\n\n  if (this._hasMethod('renderFile')) {\n    return tr.normalize(this._tr.renderFile(filename, options, locals));\n  } else if (this._hasMethod('render')) {\n    if (!options) options = {};\n    if (options.filename === undefined) options.filename = filename;\n    return tr.normalize(this._tr.render(tr.readFileSync(filename, 'utf8'), options, locals));\n  } else {\n    // compile || compileFile\n    var compiled = this.compileFile(filename, options);\n    return tr.normalize({\n      body: compiled.fn(locals || options),\n      dependencies: compiled.dependencies\n    });\n  }\n};\n\nTransformer.prototype.renderFileAsync = function (filename, options, locals, cb) {\n  if (!this.can('renderFileAsync')) {\n    // *Client\n    throw new Error('The Transform \"' + this.name + '\" does not support rendering.');\n  }\n\n  if (typeof locals === 'function') {\n    cb = locals;\n    locals = options;\n  }\n\n  if (this._hasMethod('renderFileAsync')) {\n    return tr.normalizeAsync(this._tr.renderFileAsync(filename, options, locals), cb);\n  } else if (this._hasMethod('renderFile')) {\n    return tr.normalizeAsync(this._tr.renderFile(filename, options, locals), cb);\n  } else if (this._hasMethod('compile') || this._hasMethod('compileAsync') || this._hasMethod('compileFile') || this._hasMethod('compileFileAsync')) {\n    return tr.normalizeAsync(this.compileFileAsync(filename, options).then(function (compiled) {\n      return {\n        body: compiled.fn(locals || options),\n        dependencies: compiled.dependencies\n      };\n    }), cb);\n  } else {\n    // render || renderAsync\n    if (!options) options = {};\n    if (options.filename === undefined) options.filename = filename;\n    return tr.normalizeAsync(tr.readFile(filename, 'utf8').then(function (str) {\n      return this.renderAsync(str, options, locals);\n    }.bind(this)), cb);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}