{"ast":null,"code":"'use strict';\n/*!\n * Pug\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar _lex = require('pug-lexer');\n\nvar stripComments = require('pug-strip-comments');\n\nvar _parse = require('pug-parser');\n\nvar load = require('pug-load');\n\nvar filters = require('pug-filters');\n\nvar link = require('pug-linker');\n\nvar generateCode = require('pug-code-gen');\n\nvar runtime = require('pug-runtime');\n\nvar runtimeWrap = require('pug-runtime/wrap');\n/**\n * Name for detection\n */\n\n\nexports.name = 'Pug';\n/**\n * Pug runtime helpers.\n */\n\nexports.runtime = runtime;\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\nfunction applyPlugins(value, options, plugins, name) {\n  return plugins.reduce(function (value, plugin) {\n    return plugin[name] ? plugin[name](value, options) : value;\n  }, value);\n}\n\nfunction findReplacementFunc(plugins, name) {\n  var eligiblePlugins = plugins.filter(function (plugin) {\n    return plugin[name];\n  });\n\n  if (eligiblePlugins.length > 1) {\n    throw new Error('Two or more plugins all implement ' + name + ' method.');\n  } else if (eligiblePlugins.length) {\n    return eligiblePlugins[0][name].bind(eligiblePlugins[0]);\n  }\n\n  return null;\n}\n/**\n * Object for global custom filters.  Note that you can also just pass a `filters`\n * option to any other method.\n */\n\n\nexports.filters = {};\n/**\n * Compile the given `str` of pug and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nfunction compileBody(str, options) {\n  var debug_sources = {};\n  debug_sources[options.filename] = str;\n  var dependencies = [];\n  var plugins = options.plugins || [];\n  var ast = load.string(str, {\n    filename: options.filename,\n    basedir: options.basedir,\n    lex: function lex(str, options) {\n      var lexOptions = {};\n      Object.keys(options).forEach(function (key) {\n        lexOptions[key] = options[key];\n      });\n      lexOptions.plugins = plugins.filter(function (plugin) {\n        return !!plugin.lex;\n      }).map(function (plugin) {\n        return plugin.lex;\n      });\n      var contents = applyPlugins(str, {\n        filename: options.filename\n      }, plugins, 'preLex');\n      return applyPlugins(_lex(contents, lexOptions), options, plugins, 'postLex');\n    },\n    parse: function parse(tokens, options) {\n      tokens = tokens.map(function (token) {\n        if (token.type === 'path' && path.extname(token.val) === '') {\n          return {\n            type: 'path',\n            loc: token.loc,\n            val: token.val + '.pug'\n          };\n        }\n\n        return token;\n      });\n      tokens = stripComments(tokens, options);\n      tokens = applyPlugins(tokens, options, plugins, 'preParse');\n      var parseOptions = {};\n      Object.keys(options).forEach(function (key) {\n        parseOptions[key] = options[key];\n      });\n      parseOptions.plugins = plugins.filter(function (plugin) {\n        return !!plugin.parse;\n      }).map(function (plugin) {\n        return plugin.parse;\n      });\n      return applyPlugins(applyPlugins(_parse(tokens, parseOptions), options, plugins, 'postParse'), options, plugins, 'preLoad');\n    },\n    resolve: function resolve(filename, source, loadOptions) {\n      var replacementFunc = findReplacementFunc(plugins, 'resolve');\n\n      if (replacementFunc) {\n        return replacementFunc(filename, source, options);\n      }\n\n      return load.resolve(filename, source, loadOptions);\n    },\n    read: function read(filename, loadOptions) {\n      dependencies.push(filename);\n      var contents;\n      var replacementFunc = findReplacementFunc(plugins, 'read');\n\n      if (replacementFunc) {\n        contents = replacementFunc(filename, options);\n      } else {\n        contents = load.read(filename, loadOptions);\n      }\n\n      debug_sources[filename] = Buffer.isBuffer(contents) ? contents.toString('utf8') : contents;\n      return contents;\n    }\n  });\n  ast = applyPlugins(ast, options, plugins, 'postLoad');\n  ast = applyPlugins(ast, options, plugins, 'preFilters');\n  var filtersSet = {};\n  Object.keys(exports.filters).forEach(function (key) {\n    filtersSet[key] = exports.filters[key];\n  });\n\n  if (options.filters) {\n    Object.keys(options.filters).forEach(function (key) {\n      filtersSet[key] = options.filters[key];\n    });\n  }\n\n  ast = filters.handleFilters(ast, filtersSet, options.filterOptions, options.filterAliases);\n  ast = applyPlugins(ast, options, plugins, 'postFilters');\n  ast = applyPlugins(ast, options, plugins, 'preLink');\n  ast = link(ast);\n  ast = applyPlugins(ast, options, plugins, 'postLink'); // Compile\n\n  ast = applyPlugins(ast, options, plugins, 'preCodeGen');\n  var js = (findReplacementFunc(plugins, 'generateCode') || generateCode)(ast, {\n    pretty: options.pretty,\n    compileDebug: options.compileDebug,\n    doctype: options.doctype,\n    inlineRuntimeFunctions: options.inlineRuntimeFunctions,\n    globals: options.globals,\n    self: options.self,\n    includeSources: options.includeSources ? debug_sources : false,\n    templateName: options.templateName\n  });\n  js = applyPlugins(js, options, plugins, 'postCodeGen'); // Debug compiler\n\n  if (options.debug) {\n    console.error(\"\\nCompiled Function:\\n\\n\\x1B[90m%s\\x1B[0m\", js.replace(/^/gm, '  '));\n  }\n\n  return {\n    body: js,\n    dependencies: dependencies\n  };\n}\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `str` is not set, the file specified in `options.filename` will be read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param {Object} options\n * @param {String=} str\n * @return {Function}\n * @api private\n */\n\n\nfunction handleTemplateCache(options, str) {\n  var key = options.filename;\n\n  if (options.cache && exports.cache[key]) {\n    return exports.cache[key];\n  } else {\n    if (str === undefined) str = fs.readFileSync(options.filename, 'utf8');\n    var templ = exports.compile(str, options);\n    if (options.cache) exports.cache[key] = templ;\n    return templ;\n  }\n}\n/**\n * Compile a `Function` representation of the given pug `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled\n       template, when it is explicitly `true`, the source code is included in\n       the compiled template for better accuracy.\n *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\n\nexports.compile = function (str, options) {\n  var options = options || {};\n  str = String(str);\n  var parsed = compileBody(str, {\n    compileDebug: options.compileDebug !== false,\n    filename: options.filename,\n    basedir: options.basedir,\n    pretty: options.pretty,\n    doctype: options.doctype,\n    inlineRuntimeFunctions: options.inlineRuntimeFunctions,\n    globals: options.globals,\n    self: options.self,\n    includeSources: options.compileDebug === true,\n    debug: options.debug,\n    templateName: 'template',\n    filters: options.filters,\n    filterOptions: options.filterOptions,\n    filterAliases: options.filterAliases,\n    plugins: options.plugins\n  });\n  var res = options.inlineRuntimeFunctions ? new Function('', parsed.body + ';return template;')() : runtimeWrap(parsed.body);\n  res.dependencies = parsed.dependencies;\n  return res;\n};\n/**\n * Compile a JavaScript source representation of the given pug `str`.\n *\n * Options:\n *\n *   - `compileDebug` When it is `true`, the source code is included in\n *     the compiled template for better error messages.\n *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends\n *   - `name` the name of the resulting function (defaults to \"template\")\n *   - `module` when it is explicitly `true`, the source code include export module syntax\n *\n * @param {String} str\n * @param {Options} options\n * @return {Object}\n * @api public\n */\n\n\nexports.compileClientWithDependenciesTracked = function (str, options) {\n  var options = options || {};\n  str = String(str);\n  var parsed = compileBody(str, {\n    compileDebug: options.compileDebug,\n    filename: options.filename,\n    basedir: options.basedir,\n    pretty: options.pretty,\n    doctype: options.doctype,\n    inlineRuntimeFunctions: options.inlineRuntimeFunctions !== false,\n    globals: options.globals,\n    self: options.self,\n    includeSources: options.compileDebug,\n    debug: options.debug,\n    templateName: options.name || 'template',\n    filters: options.filters,\n    filterOptions: options.filterOptions,\n    filterAliases: options.filterAliases,\n    plugins: options.plugins\n  });\n  var body = parsed.body;\n\n  if (options.module) {\n    if (options.inlineRuntimeFunctions === false) {\n      body = 'var pug = require(\"pug-runtime\");' + body;\n    }\n\n    body += ' module.exports = ' + (options.name || 'template') + ';';\n  }\n\n  return {\n    body: body,\n    dependencies: parsed.dependencies\n  };\n};\n/**\n * Compile a JavaScript source representation of the given pug `str`.\n *\n * Options:\n *\n *   - `compileDebug` When it is `true`, the source code is included in\n *     the compiled template for better error messages.\n *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends\n *   - `name` the name of the resulting function (defaults to \"template\")\n *\n * @param {String} str\n * @param {Options} options\n * @return {String}\n * @api public\n */\n\n\nexports.compileClient = function (str, options) {\n  return exports.compileClientWithDependenciesTracked(str, options).body;\n};\n/**\n * Compile a `Function` representation of the given pug file.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled\n       template, when it is explicitly `true`, the source code is included in\n       the compiled template for better accuracy.\n *\n * @param {String} path\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\n\nexports.compileFile = function (path, options) {\n  options = options || {};\n  options.filename = path;\n  return handleTemplateCache(options);\n};\n/**\n * Render the given `str` of pug.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function|undefined} fn\n * @returns {String}\n * @api public\n */\n\n\nexports.render = function (str, options, fn) {\n  // support callback API\n  if ('function' == typeof options) {\n    fn = options, options = undefined;\n  }\n\n  if (typeof fn === 'function') {\n    var res;\n\n    try {\n      res = exports.render(str, options);\n    } catch (ex) {\n      return fn(ex);\n    }\n\n    return fn(null, res);\n  }\n\n  options = options || {}; // cache requires .filename\n\n  if (options.cache && !options.filename) {\n    throw new Error('the \"filename\" option is required for caching');\n  }\n\n  return handleTemplateCache(options, str)(options);\n};\n/**\n * Render a Pug file at the given `path`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function|undefined} fn\n * @returns {String}\n * @api public\n */\n\n\nexports.renderFile = function (path, options, fn) {\n  // support callback API\n  if ('function' == typeof options) {\n    fn = options, options = undefined;\n  }\n\n  if (typeof fn === 'function') {\n    var res;\n\n    try {\n      res = exports.renderFile(path, options);\n    } catch (ex) {\n      return fn(ex);\n    }\n\n    return fn(null, res);\n  }\n\n  options = options || {};\n  options.filename = path;\n  return handleTemplateCache(options)(options);\n};\n/**\n * Compile a Pug file at the given `path` for use on the client.\n *\n * @param {String} path\n * @param {Object} options\n * @returns {String}\n * @api public\n */\n\n\nexports.compileFileClient = function (path, options) {\n  var key = path + ':client';\n  options = options || {};\n  options.filename = path;\n\n  if (options.cache && exports.cache[key]) {\n    return exports.cache[key];\n  }\n\n  var str = fs.readFileSync(options.filename, 'utf8');\n  var out = exports.compileClient(str, options);\n  if (options.cache) exports.cache[key] = out;\n  return out;\n};\n/**\n * Express support.\n */\n\n\nexports.__express = function (path, options, fn) {\n  if (options.compileDebug == undefined && process.env.NODE_ENV === 'production') {\n    options.compileDebug = false;\n  }\n\n  exports.renderFile(path, options, fn);\n};","map":null,"metadata":{},"sourceType":"script"}