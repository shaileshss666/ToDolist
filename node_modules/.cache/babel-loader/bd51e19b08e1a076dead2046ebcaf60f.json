{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar walk = require('pug-walk');\n\nfunction error() {\n  throw require('pug-error').apply(null, arguments);\n}\n\nmodule.exports = link;\n\nfunction link(ast) {\n  assert(ast.type === 'Block', 'The top level element should always be a block');\n  var extendsNode = null;\n\n  if (ast.nodes.length) {\n    var hasExtends = ast.nodes[0].type === 'Extends';\n    checkExtendPosition(ast, hasExtends);\n\n    if (hasExtends) {\n      extendsNode = ast.nodes.shift();\n    }\n  }\n\n  ast = applyIncludes(ast);\n  ast.declaredBlocks = findDeclaredBlocks(ast);\n\n  if (extendsNode) {\n    var mixins = [];\n    var expectedBlocks = [];\n    ast.nodes.forEach(function addNode(node) {\n      if (node.type === 'NamedBlock') {\n        expectedBlocks.push(node);\n      } else if (node.type === 'Block') {\n        node.nodes.forEach(addNode);\n      } else if (node.type === 'Mixin' && node.call === false) {\n        mixins.push(node);\n      } else {\n        error('UNEXPECTED_NODES_IN_EXTENDING_ROOT', 'Only named blocks and mixins can appear at the top level of an extending template', node);\n      }\n    });\n    var parent = link(extendsNode.file.ast);\n    extend(parent.declaredBlocks, ast);\n    var foundBlockNames = [];\n    walk(parent, function (node) {\n      if (node.type === 'NamedBlock') {\n        foundBlockNames.push(node.name);\n      }\n    });\n    expectedBlocks.forEach(function (expectedBlock) {\n      if (foundBlockNames.indexOf(expectedBlock.name) === -1) {\n        error('UNEXPECTED_BLOCK', 'Unexpected block ' + expectedBlock.name, expectedBlock);\n      }\n    });\n    Object.keys(ast.declaredBlocks).forEach(function (name) {\n      parent.declaredBlocks[name] = ast.declaredBlocks[name];\n    });\n    parent.nodes = mixins.concat(parent.nodes);\n    parent.hasExtends = true;\n    return parent;\n  }\n\n  return ast;\n}\n\nfunction findDeclaredBlocks(ast)\n/*: {[name: string]: Array<BlockNode>}*/\n{\n  var definitions = {};\n  walk(ast, function before(node) {\n    if (node.type === 'NamedBlock' && node.mode === 'replace') {\n      definitions[node.name] = definitions[node.name] || [];\n      definitions[node.name].push(node);\n    }\n  });\n  return definitions;\n}\n\nfunction flattenParentBlocks(parentBlocks, accumulator) {\n  accumulator = accumulator || [];\n  parentBlocks.forEach(function (parentBlock) {\n    if (parentBlock.parents) {\n      flattenParentBlocks(parentBlock.parents, accumulator);\n    }\n\n    accumulator.push(parentBlock);\n  });\n  return accumulator;\n}\n\nfunction extend(parentBlocks, ast) {\n  var stack = {};\n  walk(ast, function before(node) {\n    if (node.type === 'NamedBlock') {\n      if (stack[node.name] === node.name) {\n        return node.ignore = true;\n      }\n\n      stack[node.name] = node.name;\n      var parentBlockList = parentBlocks[node.name] ? flattenParentBlocks(parentBlocks[node.name]) : [];\n\n      if (parentBlockList.length) {\n        node.parents = parentBlockList;\n        parentBlockList.forEach(function (parentBlock) {\n          switch (node.mode) {\n            case 'append':\n              parentBlock.nodes = parentBlock.nodes.concat(node.nodes);\n              break;\n\n            case 'prepend':\n              parentBlock.nodes = node.nodes.concat(parentBlock.nodes);\n              break;\n\n            case 'replace':\n              parentBlock.nodes = node.nodes;\n              break;\n          }\n        });\n      }\n    }\n  }, function after(node) {\n    if (node.type === 'NamedBlock' && !node.ignore) {\n      delete stack[node.name];\n    }\n  });\n}\n\nfunction applyIncludes(ast, child) {\n  return walk(ast, function before(node, replace) {\n    if (node.type === 'RawInclude') {\n      replace({\n        type: 'Text',\n        val: node.file.str.replace(/\\r/g, '')\n      });\n    }\n  }, function after(node, replace) {\n    if (node.type === 'Include') {\n      var childAST = link(node.file.ast);\n\n      if (childAST.hasExtends) {\n        childAST = removeBlocks(childAST);\n      }\n\n      replace(applyYield(childAST, node.block));\n    }\n  });\n}\n\nfunction removeBlocks(ast) {\n  return walk(ast, function (node, replace) {\n    if (node.type === 'NamedBlock') {\n      replace({\n        type: 'Block',\n        nodes: node.nodes\n      });\n    }\n  });\n}\n\nfunction applyYield(ast, block) {\n  if (!block || !block.nodes.length) return ast;\n  var replaced = false;\n  ast = walk(ast, null, function (node, replace) {\n    if (node.type === 'YieldBlock') {\n      replaced = true;\n      node.type = 'Block';\n      node.nodes = [block];\n    }\n  });\n\n  function defaultYieldLocation(node) {\n    var res = node;\n\n    for (var i = 0; i < node.nodes.length; i++) {\n      if (node.nodes[i].textOnly) continue;\n\n      if (node.nodes[i].type === 'Block') {\n        res = defaultYieldLocation(node.nodes[i]);\n      } else if (node.nodes[i].block && node.nodes[i].block.nodes.length) {\n        res = defaultYieldLocation(node.nodes[i].block);\n      }\n    }\n\n    return res;\n  }\n\n  if (!replaced) {\n    // todo: probably should deprecate this with a warning\n    defaultYieldLocation(ast).nodes.push(block);\n  }\n\n  return ast;\n}\n\nfunction checkExtendPosition(ast, hasExtends) {\n  var legitExtendsReached = false;\n  walk(ast, function (node) {\n    if (node.type === 'Extends') {\n      if (hasExtends && !legitExtendsReached) {\n        legitExtendsReached = true;\n      } else {\n        error('EXTENDS_NOT_FIRST', 'Declaration of template inheritance (\"extends\") should be the first thing in the file. There can only be one extends statement per file.', node);\n      }\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}