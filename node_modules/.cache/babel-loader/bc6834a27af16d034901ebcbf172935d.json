{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar _isExpression = require('is-expression');\n\nvar characterParser = require('character-parser');\n\nvar _error = require('pug-error');\n\nmodule.exports = lex;\nmodule.exports.Lexer = Lexer;\n\nfunction lex(str, options) {\n  var lexer = new Lexer(str, options);\n  return JSON.parse(JSON.stringify(lexer.getTokens()));\n}\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * @param {String} str\n * @param {String} filename\n * @api private\n */\n\n\nfunction Lexer(str, options) {\n  options = options || {};\n\n  if (typeof str !== 'string') {\n    throw new Error('Expected source code to be a string but got \"' + typeof str + '\"');\n  }\n\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + typeof options + '\"');\n  } //Strip any UTF-8 BOM off of the start of `str`, if it exists.\n\n\n  str = str.replace(/^\\uFEFF/, '');\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.originalInput = this.input;\n  this.filename = options.filename;\n  this.interpolated = options.interpolated || false;\n  this.lineno = options.startingLine || 1;\n  this.colno = options.startingColumn || 1;\n  this.plugins = options.plugins || [];\n  this.indentStack = [0];\n  this.indentRe = null; // If #{}, !{} or #[] syntax is allowed when adding text\n\n  this.interpolationAllowed = true;\n  this.whitespaceRe = /[ \\n\\t]/;\n  this.tokens = [];\n  this.ended = false;\n}\n/**\n * Lexer prototype.\n */\n\n\nLexer.prototype = {\n  constructor: Lexer,\n  error: function error(code, message) {\n    var err = _error(code, message, {\n      line: this.lineno,\n      column: this.colno,\n      filename: this.filename,\n      src: this.originalInput\n    });\n\n    throw err;\n  },\n  assert: function assert(value, message) {\n    if (!value) this.error('ASSERT_FAILED', message);\n  },\n  isExpression: function isExpression(exp) {\n    return _isExpression(exp, {\n      throw: true\n    });\n  },\n  assertExpression: function assertExpression(exp, noThrow) {\n    //this verifies that a JavaScript expression is valid\n    try {\n      this.callLexerFunction('isExpression', exp);\n      return true;\n    } catch (ex) {\n      if (noThrow) return false; // not coming from acorn\n\n      if (!ex.loc) throw ex;\n      this.incrementLine(ex.loc.line - 1);\n      this.incrementColumn(ex.loc.column);\n      var msg = 'Syntax Error: ' + ex.message.replace(/ \\([0-9]+:[0-9]+\\)$/, '');\n      this.error('SYNTAX_ERROR', msg);\n    }\n  },\n  assertNestingCorrect: function assertNestingCorrect(exp) {\n    //this verifies that code is properly nested, but allows\n    //invalid JavaScript such as the contents of `attributes`\n    var res = characterParser(exp);\n\n    if (res.isNesting()) {\n      this.error('INCORRECT_NESTING', 'Nesting must match on expression `' + exp + '`');\n    }\n  },\n\n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n  tok: function tok(type, val) {\n    var res = {\n      type: type,\n      loc: {\n        start: {\n          line: this.lineno,\n          column: this.colno\n        },\n        filename: this.filename\n      }\n    };\n    if (val !== undefined) res.val = val;\n    return res;\n  },\n\n  /**\n   * Set the token's `loc.end` value.\n   *\n   * @param {Object} tok\n   * @returns {Object}\n   * @api private\n   */\n  tokEnd: function tokEnd(tok) {\n    tok.loc.end = {\n      line: this.lineno,\n      column: this.colno\n    };\n    return tok;\n  },\n\n  /**\n   * Increment `this.lineno` and reset `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n  incrementLine: function incrementLine(increment) {\n    this.lineno += increment;\n    if (increment) this.colno = 1;\n  },\n\n  /**\n   * Increment `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n  incrementColumn: function incrementColumn(increment) {\n    this.colno += increment;\n  },\n\n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n  consume: function consume(len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n  scan: function scan(regexp, type) {\n    var captures;\n\n    if (captures = regexp.exec(this.input)) {\n      var len = captures[0].length;\n      var val = captures[1];\n      var diff = len - (val ? val.length : 0);\n      var tok = this.tok(type, val);\n      this.consume(len);\n      this.incrementColumn(diff);\n      return tok;\n    }\n  },\n  scanEndOfLine: function scanEndOfLine(regexp, type) {\n    var captures;\n\n    if (captures = regexp.exec(this.input)) {\n      var whitespaceLength = 0;\n      var whitespace;\n      var tok;\n\n      if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {\n        whitespaceLength = whitespace[1].length;\n        this.incrementColumn(whitespaceLength);\n      }\n\n      var newInput = this.input.substr(captures[0].length);\n\n      if (newInput[0] === ':') {\n        this.input = newInput;\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n\n      if (/^[ \\t]*(\\n|$)/.test(newInput)) {\n        this.input = newInput.substr(/^[ \\t]*/.exec(newInput)[0].length);\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.\n   *\n   * Make sure that when calling this function, colno is at the character\n   * immediately before the beginning.\n   *\n   * @return {Number}\n   * @api private\n   */\n  bracketExpression: function bracketExpression(skip) {\n    skip = skip || 0;\n    var start = this.input[skip];\n    assert(start === '(' || start === '{' || start === '[', 'The start character should be \"(\", \"{\" or \"[\"');\n    var end = characterParser.BRACKETS[start];\n    var range;\n\n    try {\n      range = characterParser.parseUntil(this.input, end, {\n        start: skip + 1\n      });\n    } catch (ex) {\n      if (ex.index !== undefined) {\n        var idx = ex.index; // starting from this.input[skip]\n\n        var tmp = this.input.substr(skip).indexOf('\\n'); // starting from this.input[0]\n\n        var nextNewline = tmp + skip;\n        var ptr = 0;\n\n        while (idx > nextNewline && tmp !== -1) {\n          this.incrementLine(1);\n          idx -= nextNewline + 1;\n          ptr += nextNewline + 1;\n          tmp = nextNewline = this.input.substr(ptr).indexOf('\\n');\n        }\n\n        this.incrementColumn(idx);\n      }\n\n      if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n        this.error('NO_END_BRACKET', 'The end of the string reached with no closing bracket ' + end + ' found.');\n      } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n        this.error('BRACKET_MISMATCH', ex.message);\n      }\n\n      throw ex;\n    }\n\n    return range;\n  },\n  scanIndentation: function scanIndentation() {\n    var captures, re; // established regexp\n\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input); // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input); // spaces\n\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      } // established\n\n\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    return captures;\n  },\n\n  /**\n   * end-of-source.\n   */\n  eos: function eos() {\n    if (this.input.length) return;\n\n    if (this.interpolated) {\n      this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n    }\n\n    for (var i = 0; this.indentStack[i]; i++) {\n      this.tokens.push(this.tokEnd(this.tok('outdent')));\n    }\n\n    this.tokens.push(this.tokEnd(this.tok('eos')));\n    this.ended = true;\n    return true;\n  },\n\n  /**\n   * Blank line.\n   */\n  blank: function blank() {\n    var captures;\n\n    if (captures = /^\\n[ \\t]*\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      this.incrementLine(1);\n      return true;\n    }\n  },\n\n  /**\n   * Comment.\n   */\n  comment: function comment() {\n    var captures;\n\n    if (captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      this.interpolationAllowed = tok.buffer;\n      this.tokens.push(tok);\n      this.incrementColumn(captures[0].length);\n      this.tokEnd(tok);\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n  interpolation: function interpolation() {\n    if (/^#\\{/.test(this.input)) {\n      var match = this.bracketExpression(1);\n      this.consume(match.end + 1);\n      var tok = this.tok('interpolation', match.src);\n      this.tokens.push(tok);\n      this.incrementColumn(2); // '#{'\n\n      this.assertExpression(match.src);\n      var splitted = match.src.split('\\n');\n      var lines = splitted.length - 1;\n      this.incrementLine(lines);\n      this.incrementColumn(splitted[lines].length + 1); // + 1 â†’ '}'\n\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Tag.\n   */\n  tag: function tag() {\n    var captures;\n\n    if (captures = /^(\\w(?:[-:\\w]*\\w)?)/.exec(this.input)) {\n      var tok,\n          name = captures[1],\n          len = captures[0].length;\n      this.consume(len);\n      tok = this.tok('tag', name);\n      this.tokens.push(tok);\n      this.incrementColumn(len);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Filter.\n   */\n  filter: function filter(opts) {\n    var tok = this.scan(/^:([\\w\\-]+)/, 'filter');\n    var inInclude = opts && opts.inInclude;\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      this.callLexerFunction('attrs');\n\n      if (!inInclude) {\n        this.interpolationAllowed = false;\n        this.callLexerFunction('pipelessText');\n      }\n\n      return true;\n    }\n  },\n\n  /**\n   * Doctype.\n   */\n  doctype: function doctype() {\n    var node = this.scanEndOfLine(/^doctype *([^\\n]*)/, 'doctype');\n\n    if (node) {\n      this.tokens.push(this.tokEnd(node));\n      return true;\n    }\n  },\n\n  /**\n   * Id.\n   */\n  id: function id() {\n    var tok = this.scan(/^#([\\w-]+)/, 'id');\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n\n    if (/^#/.test(this.input)) {\n      this.error('INVALID_ID', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid ID.');\n    }\n  },\n\n  /**\n   * Class.\n   */\n  className: function className() {\n    var tok = this.scan(/^\\.([_a-z0-9\\-]*[_a-z][_a-z0-9\\-]*)/i, 'class');\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n\n    if (/^\\.[_a-z0-9\\-]+/i.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', 'Class names must contain at least one letter or underscore.');\n    }\n\n    if (/^\\./.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid class name.  Class names can only contain \"_\", \"-\", a-z and 0-9, and must contain at least one of \"_\", or a-z');\n    }\n  },\n\n  /**\n   * Text.\n   */\n  endInterpolation: function endInterpolation() {\n    if (this.interpolated && this.input[0] === ']') {\n      this.input = this.input.substr(1);\n      this.ended = true;\n      return true;\n    }\n  },\n  addText: function addText(type, value, prefix, escaped) {\n    var tok;\n    if (value + prefix === '') return;\n    prefix = prefix || '';\n    escaped = escaped || 0;\n    var indexOfEnd = this.interpolated ? value.indexOf(']') : -1;\n    var indexOfStart = this.interpolationAllowed ? value.indexOf('#[') : -1;\n    var indexOfEscaped = this.interpolationAllowed ? value.indexOf('\\\\#[') : -1;\n    var matchOfStringInterp = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(value);\n    var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;\n    if (indexOfEnd === -1) indexOfEnd = Infinity;\n    if (indexOfStart === -1) indexOfStart = Infinity;\n    if (indexOfEscaped === -1) indexOfEscaped = Infinity;\n\n    if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {\n      prefix = prefix + value.substring(0, indexOfEscaped) + '#[';\n      return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);\n    }\n\n    if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {\n      tok = this.tok(type, prefix + value.substring(0, indexOfStart));\n      this.incrementColumn(prefix.length + indexOfStart + escaped);\n      this.tokens.push(this.tokEnd(tok));\n      tok = this.tok('start-pug-interpolation');\n      this.incrementColumn(2);\n      this.tokens.push(this.tokEnd(tok));\n      var child = new this.constructor(value.substr(indexOfStart + 2), {\n        filename: this.filename,\n        interpolated: true,\n        startingLine: this.lineno,\n        startingColumn: this.colno,\n        plugins: this.plugins\n      });\n      var interpolated;\n\n      try {\n        interpolated = child.getTokens();\n      } catch (ex) {\n        if (ex.code && /^PUG:/.test(ex.code)) {\n          this.colno = ex.column;\n          this.error(ex.code.substr(4), ex.msg);\n        }\n\n        throw ex;\n      }\n\n      this.colno = child.colno;\n      this.tokens = this.tokens.concat(interpolated);\n      tok = this.tok('end-pug-interpolation');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.addText(type, child.input);\n      return;\n    }\n\n    if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {\n      if (prefix + value.substring(0, indexOfEnd)) {\n        this.addText(type, value.substring(0, indexOfEnd), prefix);\n      }\n\n      this.ended = true;\n      this.input = value.substr(value.indexOf(']') + 1) + this.input;\n      return;\n    }\n\n    if (indexOfStringInterp !== Infinity) {\n      if (matchOfStringInterp[1]) {\n        prefix = prefix + value.substring(0, indexOfStringInterp) + matchOfStringInterp[2] + '{';\n        return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);\n      }\n\n      var before = value.substr(0, indexOfStringInterp);\n\n      if (prefix || before) {\n        before = prefix + before;\n        tok = this.tok(type, before);\n        this.incrementColumn(before.length + escaped);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      var rest = matchOfStringInterp[3];\n      var range;\n      tok = this.tok('interpolated-code');\n      this.incrementColumn(2);\n\n      try {\n        range = characterParser.parseUntil(rest, '}');\n      } catch (ex) {\n        if (ex.index !== undefined) {\n          this.incrementColumn(ex.index);\n        }\n\n        if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n          this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n        } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n          this.error('BRACKET_MISMATCH', ex.message);\n        } else {\n          throw ex;\n        }\n      }\n\n      tok.mustEscape = matchOfStringInterp[2] === '#';\n      tok.buffer = true;\n      tok.val = range.src;\n      this.assertExpression(range.src);\n\n      if (range.end + 1 < rest.length) {\n        rest = rest.substr(range.end + 1);\n        this.incrementColumn(range.end + 1);\n        this.tokens.push(this.tokEnd(tok));\n        this.addText(type, rest);\n      } else {\n        this.incrementColumn(rest.length);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      return;\n    }\n\n    value = prefix + value;\n    tok = this.tok(type, value);\n    this.incrementColumn(value.length + escaped);\n    this.tokens.push(this.tokEnd(tok));\n  },\n  text: function text() {\n    var tok = this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') || this.scan(/^( )/, 'text') || this.scan(/^\\|( ?)/, 'text');\n\n    if (tok) {\n      this.addText('text', tok.val);\n      return true;\n    }\n  },\n  textHtml: function textHtml() {\n    var tok = this.scan(/^(<[^\\n]*)/, 'text-html');\n\n    if (tok) {\n      this.addText('text-html', tok.val);\n      return true;\n    }\n  },\n\n  /**\n   * Dot.\n   */\n  dot: function dot() {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^\\./, 'dot')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Extends.\n   */\n  extends: function _extends() {\n    var tok = this.scan(/^extends?(?= |$|\\n)/, 'extends');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n\n      if (!this.callLexerFunction('path')) {\n        this.error('NO_EXTENDS_PATH', 'missing path for extends');\n      }\n\n      return true;\n    }\n\n    if (this.scan(/^extends?\\b/)) {\n      this.error('MALFORMED_EXTENDS', 'malformed extends');\n    }\n  },\n\n  /**\n   * Block prepend.\n   */\n  prepend: function prepend() {\n    var captures;\n\n    if (captures = /^(?:block +)?prepend +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) {\n        len--;\n      }\n\n      this.incrementColumn(len);\n      tok.mode = 'prepend';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block append.\n   */\n  append: function append() {\n    var captures;\n\n    if (captures = /^(?:block +)?append +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) {\n        len--;\n      }\n\n      this.incrementColumn(len);\n      tok.mode = 'append';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block.\n   */\n  block: function block() {\n    var captures;\n\n    if (captures = /^block +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) {\n        len--;\n      }\n\n      this.incrementColumn(len);\n      tok.mode = 'replace';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Mixin Block.\n   */\n  mixinBlock: function mixinBlock() {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^block/, 'mixin-block')) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n  yield: function _yield() {\n    var tok = this.scanEndOfLine(/^yield/, 'yield');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Include.\n   */\n  include: function include() {\n    var tok = this.scan(/^include(?=:| |$|\\n)/, 'include');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n\n      while (this.callLexerFunction('filter', {\n        inInclude: true\n      })) {\n        ;\n      }\n\n      if (!this.callLexerFunction('path')) {\n        if (/^[^ \\n]+/.test(this.input)) {\n          // if there is more text\n          this.fail();\n        } else {\n          // if not\n          this.error('NO_INCLUDE_PATH', 'missing path for include');\n        }\n      }\n\n      return true;\n    }\n\n    if (this.scan(/^include\\b/)) {\n      this.error('MALFORMED_INCLUDE', 'malformed include');\n    }\n  },\n\n  /**\n   * Path\n   */\n  path: function path() {\n    var tok = this.scanEndOfLine(/^ ([^\\n]+)/, 'path');\n\n    if (tok && (tok.val = tok.val.trim())) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Case.\n   */\n  case: function _case() {\n    var tok = this.scanEndOfLine(/^case +([^\\n]+)/, 'case');\n\n    if (tok) {\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^case\\b/)) {\n      this.error('NO_CASE_EXPRESSION', 'missing expression for case');\n    }\n  },\n\n  /**\n   * When.\n   */\n  when: function when() {\n    var tok = this.scanEndOfLine(/^when +([^:\\n]+)/, 'when');\n\n    if (tok) {\n      var parser = characterParser(tok.val);\n\n      while (parser.isNesting() || parser.isString()) {\n        var rest = /:([^:\\n]+)/.exec(this.input);\n        if (!rest) break;\n        tok.val += rest[0];\n        this.consume(rest[0].length);\n        this.incrementColumn(rest[0].length);\n        parser = characterParser(tok.val);\n      }\n\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^when\\b/)) {\n      this.error('NO_WHEN_EXPRESSION', 'missing expression for when');\n    }\n  },\n\n  /**\n   * Default.\n   */\n  default: function _default() {\n    var tok = this.scanEndOfLine(/^default/, 'default');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^default\\b/)) {\n      this.error('DEFAULT_WITH_EXPRESSION', 'default should not have an expression');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n  call: function call() {\n    var tok, captures, increment;\n\n    if (captures = /^\\+(\\s*)(([-\\w]+)|(#\\{))/.exec(this.input)) {\n      // try to consume simple or interpolated call\n      if (captures[3]) {\n        // simple call\n        increment = captures[0].length;\n        this.consume(increment);\n        tok = this.tok('call', captures[3]);\n      } else {\n        // interpolated call\n        var match = this.bracketExpression(2 + captures[1].length);\n        increment = match.end + 1;\n        this.consume(increment);\n        this.assertExpression(match.src);\n        tok = this.tok('call', '#{' + match.src + '}');\n      }\n\n      this.incrementColumn(increment);\n      tok.args = null; // Check for args (not attributes)\n\n      if (captures = /^ *\\(/.exec(this.input)) {\n        var range = this.bracketExpression(captures[0].length - 1);\n\n        if (!/^\\s*[-\\w]+ *=/.test(range.src)) {\n          // not attributes\n          this.incrementColumn(1);\n          this.consume(range.end + 1);\n          tok.args = range.src;\n          this.assertExpression('[' + tok.args + ']');\n\n          for (var i = 0; i <= tok.args.length; i++) {\n            if (tok.args[i] === '\\n') {\n              this.incrementLine(1);\n            } else {\n              this.incrementColumn(1);\n            }\n          }\n        }\n      }\n\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n  mixin: function mixin() {\n    var captures;\n\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2] || null;\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n  conditional: function conditional() {\n    var captures;\n\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1].replace(/ /g, '-');\n      var js = captures[2] && captures[2].trim(); // type can be \"if\", \"else-if\" and \"else\"\n\n      var tok = this.tok(type, js);\n      this.incrementColumn(captures[0].length - js.length);\n\n      switch (type) {\n        case 'if':\n        case 'else-if':\n          this.assertExpression(js);\n          break;\n\n        case 'unless':\n          this.assertExpression(js);\n          tok.val = '!(' + js + ')';\n          tok.type = 'if';\n          break;\n\n        case 'else':\n          if (js) {\n            this.error('ELSE_CONDITION', '`else` cannot have a condition, perhaps you meant `else if`');\n          }\n\n          break;\n      }\n\n      this.incrementColumn(js.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * While.\n   */\n  while: function _while() {\n    var captures, tok;\n\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      this.assertExpression(captures[1]);\n      tok = this.tok('while', captures[1]);\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^while\\b/)) {\n      this.error('NO_WHILE_EXPRESSION', 'missing expression for while');\n    }\n  },\n\n  /**\n   * Each.\n   */\n  each: function each() {\n    var captures;\n\n    if (captures = /^(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || null;\n      this.incrementColumn(captures[0].length - captures[3].length);\n      this.assertExpression(captures[3]);\n      tok.code = captures[3];\n      this.incrementColumn(captures[3].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    var name = /^each\\b/.exec(this.input) ? 'each' : 'for';\n\n    if (this.scan(/^(?:each|for)\\b/)) {\n      this.error('MALFORMED_EACH', 'This `' + name + '` has a syntax error. `' + name + '` statements should be of the form: `' + name + ' VARIABLE_NAME of JS_EXPRESSION`');\n    }\n\n    if (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +in +([^\\n]+)/.exec(this.input)) {\n      this.error('MALFORMED_EACH', 'Pug each and for should no longer be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.');\n    }\n  },\n\n  /**\n   * EachOf.\n   */\n  eachOf: function eachOf() {\n    var captures;\n\n    if (captures = /^(?:each|for) (.*?) of *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('eachOf', captures[1]);\n      tok.value = captures[1];\n      this.incrementColumn(captures[0].length - captures[2].length);\n      this.assertExpression(captures[2]);\n      tok.code = captures[2];\n      this.incrementColumn(captures[2].length);\n      this.tokens.push(this.tokEnd(tok));\n\n      if (!(/^[a-zA-Z_$][\\w$]*$/.test(tok.value.trim()) || /^\\[ *[a-zA-Z_$][\\w$]* *\\, *[a-zA-Z_$][\\w$]* *\\]$/.test(tok.value.trim()))) {\n        this.error('MALFORMED_EACH_OF_LVAL', 'The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).');\n      }\n\n      return true;\n    }\n\n    if (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +of +([^\\n]+)/.exec(this.input)) {\n      this.error('MALFORMED_EACH', 'Pug each and for should not be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.');\n    }\n  },\n\n  /**\n   * Code.\n   */\n  code: function code() {\n    var captures;\n\n    if (captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input)) {\n      var flags = captures[1];\n      var code = captures[2];\n      var shortened = 0;\n\n      if (this.interpolated) {\n        var parsed;\n\n        try {\n          parsed = characterParser.parseUntil(code, ']');\n        } catch (err) {\n          if (err.index !== undefined) {\n            this.incrementColumn(captures[0].length - code.length + err.index);\n          }\n\n          if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n            this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n          } else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n            this.error('BRACKET_MISMATCH', err.message);\n          } else {\n            throw err;\n          }\n        }\n\n        shortened = code.length - parsed.end;\n        code = parsed.src;\n      }\n\n      var consumed = captures[0].length - shortened;\n      this.consume(consumed);\n      var tok = this.tok('code', code);\n      tok.mustEscape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '='; // p #[!=    abc] hey\n      //     ^              original colno\n      //     -------------- captures[0]\n      //           -------- captures[2]\n      //     ------         captures[0] - captures[2]\n      //           ^        after colno\n      // =   abc\n      // ^                  original colno\n      // -------            captures[0]\n      //     ---            captures[2]\n      // ----               captures[0] - captures[2]\n      //     ^              after colno\n\n      this.incrementColumn(captures[0].length - captures[2].length);\n      if (tok.buffer) this.assertExpression(code);\n      this.tokens.push(tok); // p #[!=    abc] hey\n      //           ^        original colno\n      //              ----- shortened\n      //           ---      code\n      //              ^     after colno\n      // =   abc\n      //     ^              original colno\n      //                    shortened\n      //     ---            code\n      //        ^           after colno\n\n      this.incrementColumn(code.length);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Block code.\n   */\n  blockCode: function blockCode() {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^-/, 'blockcode')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.interpolationAllowed = false;\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Attribute Name.\n   */\n  attribute: function attribute(str) {\n    var quote = '';\n    var quoteRe = /['\"]/;\n    var key = '';\n    var i; // consume all whitespace before the key\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (i === str.length) {\n      return '';\n    }\n\n    var tok = this.tok('attribute'); // quote?\n\n    if (quoteRe.test(str[i])) {\n      quote = str[i];\n      this.incrementColumn(1);\n      i++;\n    } // start looping through the key\n\n\n    for (; i < str.length; i++) {\n      if (quote) {\n        if (str[i] === quote) {\n          this.incrementColumn(1);\n          i++;\n          break;\n        }\n      } else {\n        if (this.whitespaceRe.test(str[i]) || str[i] === '!' || str[i] === '=' || str[i] === ',') {\n          break;\n        }\n      }\n\n      key += str[i];\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    tok.name = key;\n    var valueResponse = this.attributeValue(str.substr(i));\n\n    if (valueResponse.val) {\n      tok.val = valueResponse.val;\n      tok.mustEscape = valueResponse.mustEscape;\n    } else {\n      // was a boolean attribute (ex: `input(disabled)`)\n      tok.val = true;\n      tok.mustEscape = true;\n    }\n\n    str = valueResponse.remainingSource;\n    this.tokens.push(this.tokEnd(tok));\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) {\n        break;\n      }\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (str[i] === ',') {\n      this.incrementColumn(1);\n      i++;\n    }\n\n    return str.substr(i);\n  },\n\n  /**\n   * Attribute Value.\n   */\n  attributeValue: function attributeValue(str) {\n    var quoteRe = /['\"]/;\n    var val = '';\n    var done, i, x;\n    var escapeAttr = true;\n    var state = characterParser.defaultState();\n    var col = this.colno;\n    var line = this.lineno; // consume all whitespace before the equals sign\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    if (i === str.length) {\n      return {\n        remainingSource: str\n      };\n    }\n\n    if (str[i] === '!') {\n      escapeAttr = false;\n      col++;\n      i++;\n      if (str[i] !== '=') this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[i] + ' expected `=`');\n    }\n\n    if (str[i] !== '=') {\n      // check for anti-pattern `div(\"foo\"bar)`\n      if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ',') {\n        this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[0] + ' expected `=`');\n      } else {\n        return {\n          remainingSource: str\n        };\n      }\n    }\n\n    this.lineno = line;\n    this.colno = col + 1;\n    i++; // consume all whitespace before the value\n\n    for (; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    line = this.lineno;\n    col = this.colno; // start looping through the value\n\n    for (; i < str.length; i++) {\n      // if the character is in a string or in parentheses/brackets/braces\n      if (!(state.isNesting() || state.isString())) {\n        if (this.whitespaceRe.test(str[i])) {\n          done = false; // find the first non-whitespace character\n\n          for (x = i; x < str.length; x++) {\n            if (!this.whitespaceRe.test(str[x])) {\n              // if it is a JavaScript punctuator, then assume that it is\n              // a part of the value\n              var isNotPunctuator = !characterParser.isPunctuator(str[x]);\n              var isQuote = quoteRe.test(str[x]);\n              var isColon = str[x] === ':';\n              var isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === '...';\n\n              if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) {\n                done = true;\n              }\n\n              break;\n            }\n          } // if everything else is whitespace, return now so last attribute\n          // does not include trailing whitespace\n\n\n          if (done || x === str.length) {\n            break;\n          }\n        } // if there's no whitespace and the character is not ',', the\n        // attribute did not end.\n\n\n        if (str[i] === ',' && this.assertExpression(val, true)) {\n          break;\n        }\n      }\n\n      state = characterParser.parseChar(str[i], state);\n      val += str[i];\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    this.assertExpression(val);\n    this.lineno = line;\n    this.colno = col;\n    return {\n      val: val,\n      mustEscape: escapeAttr,\n      remainingSource: str.substr(i)\n    };\n  },\n\n  /**\n   * Attributes.\n   */\n  attrs: function attrs() {\n    var tok;\n\n    if ('(' == this.input.charAt(0)) {\n      tok = this.tok('start-attributes');\n      var index = this.bracketExpression().end;\n      var str = this.input.substr(1, index - 1);\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.assertNestingCorrect(str);\n      this.consume(index + 1);\n\n      while (str) {\n        str = this.attribute(str);\n      }\n\n      tok = this.tok('end-attributes');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * &attributes block\n   */\n  attributesBlock: function attributesBlock() {\n    if (/^&attributes\\b/.test(this.input)) {\n      var consumed = 11;\n      this.consume(consumed);\n      var tok = this.tok('&attributes');\n      this.incrementColumn(consumed);\n      var args = this.bracketExpression();\n      consumed = args.end + 1;\n      this.consume(consumed);\n      tok.val = args.src;\n      this.incrementColumn(consumed);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Indent | Outdent | Newline.\n   */\n  indent: function indent() {\n    var captures = this.scanIndentation();\n    var tok;\n\n    if (captures) {\n      var indents = captures[1].length;\n      this.incrementLine(1);\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        this.error('INVALID_INDENTATION', 'Invalid indentation, you can use tabs or spaces but not both');\n      } // blank line\n\n\n      if ('\\n' == this.input[0]) {\n        this.interpolationAllowed = true;\n        return this.tokEnd(this.tok('newline'));\n      } // outdent\n\n\n      if (indents < this.indentStack[0]) {\n        var outdent_count = 0;\n\n        while (this.indentStack[0] > indents) {\n          if (this.indentStack[1] < indents) {\n            this.error('INCONSISTENT_INDENTATION', 'Inconsistent indentation. Expecting either ' + this.indentStack[1] + ' or ' + this.indentStack[0] + ' spaces/tabs.');\n          }\n\n          outdent_count++;\n          this.indentStack.shift();\n        }\n\n        while (outdent_count--) {\n          this.colno = 1;\n          tok = this.tok('outdent');\n          this.colno = this.indentStack[0] + 1;\n          this.tokens.push(this.tokEnd(tok));\n        } // indent\n\n      } else if (indents && indents != this.indentStack[0]) {\n        tok = this.tok('indent', indents);\n        this.colno = 1 + indents;\n        this.tokens.push(this.tokEnd(tok));\n        this.indentStack.unshift(indents); // newline\n      } else {\n        tok = this.tok('newline');\n        this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      this.interpolationAllowed = true;\n      return true;\n    }\n  },\n  pipelessText: function pipelessText(indents) {\n    while (this.callLexerFunction('blank')) {\n      ;\n    }\n\n    var captures = this.scanIndentation();\n    indents = indents || captures && captures[1].length;\n\n    if (indents > this.indentStack[0]) {\n      this.tokens.push(this.tokEnd(this.tok('start-pipeless-text')));\n      var tokens = [];\n      var token_indent = [];\n      var isMatch; // Index in this.input. Can't use this.consume because we might need to\n      // retry lexing the block.\n\n      var stringPtr = 0;\n\n      do {\n        // text has `\\n` as a prefix\n        var i = this.input.substr(stringPtr + 1).indexOf('\\n');\n        if (-1 == i) i = this.input.length - stringPtr - 1;\n        var str = this.input.substr(stringPtr + 1, i);\n        var lineCaptures = this.indentRe.exec('\\n' + str);\n        var lineIndents = lineCaptures && lineCaptures[1].length;\n        isMatch = lineIndents >= indents;\n        token_indent.push(isMatch);\n        isMatch = isMatch || !str.trim();\n\n        if (isMatch) {\n          // consume test along with `\\n` prefix if match\n          stringPtr += str.length + 1;\n          tokens.push(str.substr(indents));\n        } else if (lineIndents > this.indentStack[0]) {\n          // line is indented less than the first line but is still indented\n          // need to retry lexing the text block\n          this.tokens.pop();\n          return pipelessText.call(this, lineCaptures[1].length);\n        }\n      } while (this.input.length - stringPtr && isMatch);\n\n      this.consume(stringPtr);\n\n      while (this.input.length === 0 && tokens[tokens.length - 1] === '') {\n        tokens.pop();\n      }\n\n      tokens.forEach(function (token, i) {\n        var tok;\n        this.incrementLine(1);\n        if (i !== 0) tok = this.tok('newline');\n        if (token_indent[i]) this.incrementColumn(indents);\n        if (tok) this.tokens.push(this.tokEnd(tok));\n        this.addText('text', token);\n      }.bind(this));\n      this.tokens.push(this.tokEnd(this.tok('end-pipeless-text')));\n      return true;\n    }\n  },\n\n  /**\n   * Slash.\n   */\n  slash: function slash() {\n    var tok = this.scan(/^\\//, 'slash');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * ':'\n   */\n  colon: function colon() {\n    var tok = this.scan(/^: +/, ':');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n  fail: function fail() {\n    this.error('UNEXPECTED_TEXT', 'unexpected text \"' + this.input.substr(0, 5) + '\"');\n  },\n  callLexerFunction: function callLexerFunction(func) {\n    var rest = [];\n\n    for (var i = 1; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n\n    var pluginArgs = [this].concat(rest);\n\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n\n      if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {\n        return true;\n      }\n    }\n\n    return this[func].apply(this, rest);\n  },\n\n  /**\n   * Move to the next token\n   *\n   * @api private\n   */\n  advance: function advance() {\n    return this.callLexerFunction('blank') || this.callLexerFunction('eos') || this.callLexerFunction('endInterpolation') || this.callLexerFunction('yield') || this.callLexerFunction('doctype') || this.callLexerFunction('interpolation') || this.callLexerFunction('case') || this.callLexerFunction('when') || this.callLexerFunction('default') || this.callLexerFunction('extends') || this.callLexerFunction('append') || this.callLexerFunction('prepend') || this.callLexerFunction('block') || this.callLexerFunction('mixinBlock') || this.callLexerFunction('include') || this.callLexerFunction('mixin') || this.callLexerFunction('call') || this.callLexerFunction('conditional') || this.callLexerFunction('eachOf') || this.callLexerFunction('each') || this.callLexerFunction('while') || this.callLexerFunction('tag') || this.callLexerFunction('filter') || this.callLexerFunction('blockCode') || this.callLexerFunction('code') || this.callLexerFunction('id') || this.callLexerFunction('dot') || this.callLexerFunction('className') || this.callLexerFunction('attrs') || this.callLexerFunction('attributesBlock') || this.callLexerFunction('indent') || this.callLexerFunction('text') || this.callLexerFunction('textHtml') || this.callLexerFunction('comment') || this.callLexerFunction('slash') || this.callLexerFunction('colon') || this.fail();\n  },\n\n  /**\n   * Return an array of tokens for the current file\n   *\n   * @returns {Array.<Token>}\n   * @api public\n   */\n  getTokens: function getTokens() {\n    while (!this.ended) {\n      this.callLexerFunction('advance');\n    }\n\n    return this.tokens;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}